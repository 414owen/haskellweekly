-- | This module defines a type for capturing all of the configuration
-- necessary to start the Haskell Weekly server.
module HW.Type.Config
  ( Config(..)
  , getConfig
  )
where

import qualified Data.ByteString
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Text.Encoding
import qualified HW.Type.BaseUrl
import qualified Network.Wai.Handler.Warp
import qualified System.Environment
import qualified Text.Read

data Config =
  Config
    { configBaseUrl :: HW.Type.BaseUrl.BaseUrl
    , configDatabaseUrl :: Data.ByteString.ByteString
    , configDataDirectory :: FilePath
    , configGoogleSiteVerification :: Maybe Data.Text.Text
    , configPort :: Network.Wai.Handler.Warp.Port
    }
  deriving (Eq, Show)

-- | Gets all the necessary pieces of the 'Config' and stitches them together.
-- Note that even if the config is valid, the server might fail to start. For
-- example if the database URL is syntactically valid but the database doesn't
-- actually exist.
getConfig :: IO Config
getConfig = do
  databaseUrl <- getDatabaseUrl
  dataDirectory <- getDataDirectory
  googleSiteVerification <- getGoogleSiteVerification
  port <- getPort
  baseUrl <- getBaseUrl
  pure Config
    { configBaseUrl = baseUrl
    , configDatabaseUrl = databaseUrl
    , configDataDirectory = dataDirectory
    , configGoogleSiteVerification = googleSiteVerification
    , configPort = port
    }

-- | Gets the base URL that the server will be available at. This is necessary
-- because the server could be behind a reverse proxy or in a container or
-- something.
getBaseUrl :: IO HW.Type.BaseUrl.BaseUrl
getBaseUrl =
  fmap (HW.Type.BaseUrl.textToBaseUrl . maybe Data.Text.empty Data.Text.pack)
    $ System.Environment.lookupEnv "BASE_URL"

-- | Gets the database connection information. Although this says "URL" it
-- -- could also be a PostgreSQL connection string. That means both
-- -- @postgresql://...@ URLs and stuff like @host=...@ work. Also be aware that
-- -- normal @PG*@ environment variables also play into this.
getDatabaseUrl :: IO Data.ByteString.ByteString
getDatabaseUrl = do
  maybeString <- System.Environment.lookupEnv "DATABASE_URL"
  pure $ case maybeString of
    Nothing -> Data.ByteString.empty
    Just string -> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack string

-- | Gets the directory where all the data files are stored. You might think
-- this could use @getDataFileName@ from the autogenerated package module, but
-- that doesn't work nicely with new style Cabal builds and multi stage Docker
-- builds.
getDataDirectory :: IO FilePath
getDataDirectory = do
  maybeString <- System.Environment.lookupEnv "DATA_DIRECTORY"
  pure $ Data.Maybe.fromMaybe "data" maybeString

-- | This is used to verify that I actually own the website as far as Google is
-- concerned. The verification is useful for Google's webmaster tools.
getGoogleSiteVerification :: IO (Maybe Data.Text.Text)
getGoogleSiteVerification = do
  maybeString <- System.Environment.lookupEnv "GOOGLE_SITE_VERIFICATION"
  pure $ fmap Data.Text.pack maybeString

-- | Gets the port that the server should run on. By default this is @8080@.
getPort :: IO Network.Wai.Handler.Warp.Port
getPort = do
  maybeString <- System.Environment.lookupEnv "PORT"
  case maybeString of
    Nothing -> pure 8080
    Just string -> case Text.Read.readMaybe string of
      Nothing -> fail $ "invalid PORT: " <> show string
      Just port -> pure port
