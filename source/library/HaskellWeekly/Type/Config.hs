-- | This module defines a type for capturing all of the configuration
-- necessary to start the Haskell Weekly server.
module HaskellWeekly.Type.Config
  ( Config(..)
  , getConfig
  )
where

import qualified Data.ByteString
import qualified Data.Maybe
import qualified Data.Text
import qualified Data.Text.Encoding
import qualified HaskellWeekly.Type.BaseUrl
import qualified Network.Wai.Handler.Warp
import qualified System.Environment
import qualified Text.Read

data Config =
  Config
    { configBaseUrl :: HaskellWeekly.Type.BaseUrl.BaseUrl
    , configDatabaseUrl :: Data.ByteString.ByteString
    , configDataDirectory :: FilePath
    , configPort :: Network.Wai.Handler.Warp.Port
    }
  deriving (Eq, Show)

-- | Gets all the necessary pieces of the 'Config' and stitches them together.
-- Note that even if the config is valid, the server might fail to start. For
-- example if the database URL is syntactically valid but the database doesn't
-- actually exist.
getConfig :: IO Config
getConfig = do
  databaseUrl <- getDatabaseUrl
  dataDirectory <- getDataDirectory
  port <- getPort
  baseUrl <- getBaseUrl port
  pure Config
    { configBaseUrl = baseUrl
    , configDatabaseUrl = databaseUrl
    , configDataDirectory = dataDirectory
    , configPort = port
    }

-- | Gets the base URL that the server will be available at. This is necessary
-- because the server could be behind a reverse proxy or in a container or
-- something.
getBaseUrl :: Network.Wai.Handler.Warp.Port -> IO HaskellWeekly.Type.BaseUrl.BaseUrl
getBaseUrl port = do
  maybeString <- System.Environment.lookupEnv "BASE_URL"
  pure
    . HaskellWeekly.Type.BaseUrl.textToBaseUrl
    . Data.Text.pack
    $ Data.Maybe.fromMaybe ("http://localhost:" <> show port) maybeString

-- | Gets the database connection information. Although this says "URL" it
-- could also be a PostgreSQL connection string. That means both
-- @postgresql://...@ URLs and stuff like @host=...@ work. Also be aware that
-- normal @PG*@ environment variables also play into this.
getDatabaseUrl :: IO Data.ByteString.ByteString
getDatabaseUrl = do
  maybeString <- System.Environment.lookupEnv "DATABASE_URL"
  pure $ case maybeString of
    Nothing -> Data.ByteString.empty
    Just string -> Data.Text.Encoding.encodeUtf8 $ Data.Text.pack string

-- | Gets the directory where all the data files are stored. You might think
-- this could use @getDataFileName@ from the autogenerated package module, but
-- that doesn't work nicely with new style Cabal builds and multi stage Docker
-- builds.
getDataDirectory :: IO FilePath
getDataDirectory = do
  maybeString <- System.Environment.lookupEnv "DATA_DIRECTORY"
  pure $ Data.Maybe.fromMaybe "data" maybeString

-- | Gets the port that the server should run on. By default this is @8080@.
getPort :: IO Network.Wai.Handler.Warp.Port
getPort = do
  maybeString <- System.Environment.lookupEnv "PORT"
  case maybeString of
    Nothing -> pure 8080
    Just string -> case Text.Read.readMaybe string of
      Nothing -> fail $ "invalid PORT: " <> show string
      Just port -> pure port
