1
00:00:01,669 --> 00:00:05,790
hello and welcome to the Haskell weekly

2
00:00:04,020 --> 00:00:08,309
podcast as you might have guessed this

3
00:00:05,790 --> 00:00:09,660
show is about Haskell which is a purely

4
00:00:08,309 --> 00:00:12,120
functional programming language

5
00:00:09,660 --> 00:00:18,510
I'm your host Taylor Foss ak I'm the

6
00:00:12,120 --> 00:00:20,279
lead engineer at IT Pro TV thanks for

7
00:00:18,510 --> 00:00:22,170
joining me today Cody what are we gonna

8
00:00:20,279 --> 00:00:25,199
be talking about we are going to be

9
00:00:22,170 --> 00:00:29,250
following a blog post called inventing

10
00:00:25,199 --> 00:00:30,630
mana it's talking through it cool I feel

11
00:00:29,250 --> 00:00:32,669
like I've been programming high school

12
00:00:30,630 --> 00:00:34,500
for a while so I'm familiar with my nads

13
00:00:32,669 --> 00:00:37,530
but this is more of a beginner's

14
00:00:34,500 --> 00:00:40,440
perspective right right he tries to

15
00:00:37,530 --> 00:00:42,329
actually go through and start using or

16
00:00:40,440 --> 00:00:44,760
he uses JavaScript throughout all of his

17
00:00:42,329 --> 00:00:46,530
examples to make it a little more

18
00:00:44,760 --> 00:00:49,980
approachable since that's kind of the

19
00:00:46,530 --> 00:00:51,989
lingua franca yeah for sure

20
00:00:49,980 --> 00:00:54,539
javascript you know use just a little

21
00:00:51,989 --> 00:00:56,820
bit more than Haskell in industry and

22
00:00:54,539 --> 00:00:58,800
it's nice to see that the concept of

23
00:00:56,820 --> 00:01:00,660
mods can be applied in other languages

24
00:00:58,800 --> 00:01:04,439
it's not something that is specific to a

25
00:01:00,660 --> 00:01:06,150
school right so you mentioned that he he

26
00:01:04,439 --> 00:01:08,100
does this in JavaScript so how does he

27
00:01:06,150 --> 00:01:09,630
start off because I know that Haskell

28
00:01:08,100 --> 00:01:11,100
and JavaScript represent things a lot

29
00:01:09,630 --> 00:01:13,380
differently so it's kind of weird to see

30
00:01:11,100 --> 00:01:16,500
that as a starting point right he just

31
00:01:13,380 --> 00:01:19,170
starts with a normal kind of JavaScript

32
00:01:16,500 --> 00:01:21,990
block of a function of how you would get

33
00:01:19,170 --> 00:01:24,360
a middle name you have a function and

34
00:01:21,990 --> 00:01:26,040
two constants in it a function call and

35
00:01:24,360 --> 00:01:29,180
two constants in it mm-hmm

36
00:01:26,040 --> 00:01:32,310
then he does a sort of pointless looking

37
00:01:29,180 --> 00:01:35,520
transformation where he introduces an

38
00:01:32,310 --> 00:01:39,210
apply function and he uses that apply

39
00:01:35,520 --> 00:01:42,600
function to get the middle name and then

40
00:01:39,210 --> 00:01:46,220
he calls the get user function on that

41
00:01:42,600 --> 00:01:50,250
and then the apply above that as well

42
00:01:46,220 --> 00:01:52,979
then finally calling get ID with all of

43
00:01:50,250 --> 00:01:54,240
those things and the except supplies on

44
00:01:52,979 --> 00:01:55,950
it gotcha

45
00:01:54,240 --> 00:01:59,880
so he has this kind of straightforward

46
00:01:55,950 --> 00:02:02,549
JavaScript function and he transforms it

47
00:01:59,880 --> 00:02:04,860
throwing a seemingly unnecessary amount

48
00:02:02,549 --> 00:02:07,979
of abstraction in there but I have to

49
00:02:04,860 --> 00:02:10,410
assume it'll come in handy later right

50
00:02:07,979 --> 00:02:12,450
he calls it a dense representation it

51
00:02:10,410 --> 00:02:14,040
totally looks pointless and it's like oh

52
00:02:12,450 --> 00:02:16,980
god why would you do this

53
00:02:14,040 --> 00:02:19,930
yeah well hopefully he'll tell us and

54
00:02:16,980 --> 00:02:21,490
it's interesting here that JavaScript

55
00:02:19,930 --> 00:02:23,050
and Haskell again are such different

56
00:02:21,490 --> 00:02:24,970
languages but he manages to make a

57
00:02:23,050 --> 00:02:26,800
function call syntax that ends up

58
00:02:24,970 --> 00:02:28,030
looking pretty close to Haskell so if

59
00:02:26,800 --> 00:02:30,010
you kind of squint your eyes a little

60
00:02:28,030 --> 00:02:31,569
bit you could imagine this javascript is

61
00:02:30,010 --> 00:02:33,970
actually Haskell which is nice for me

62
00:02:31,569 --> 00:02:35,980
yeah great so now that we've thrown all

63
00:02:33,970 --> 00:02:37,569
this extra syntax and boilerplate in

64
00:02:35,980 --> 00:02:38,800
front of ourselves what do we actually

65
00:02:37,569 --> 00:02:40,780
get out of it what's the first thing

66
00:02:38,800 --> 00:02:43,840
that he does with this stuff well the

67
00:02:40,780 --> 00:02:45,280
first thing is he poses the question you

68
00:02:43,840 --> 00:02:48,430
know what if ID

69
00:02:45,280 --> 00:02:50,920
middle name user if any of those things

70
00:02:48,430 --> 00:02:53,680
could be null which super coming right

71
00:02:50,920 --> 00:02:55,570
right right you know anything fails

72
00:02:53,680 --> 00:02:56,890
you'll you'll get a null is especially

73
00:02:55,570 --> 00:03:01,510
in JavaScript mm-hm

74
00:02:56,890 --> 00:03:03,580
he gives a code snippet where the get ID

75
00:03:01,510 --> 00:03:07,330
and get user functions are now checking

76
00:03:03,580 --> 00:03:09,519
for null same forget middle name right

77
00:03:07,330 --> 00:03:11,290
so I'm showing you kind of the more

78
00:03:09,519 --> 00:03:13,330
typical JavaScript way of approaching

79
00:03:11,290 --> 00:03:16,360
this problem right correct and showing

80
00:03:13,330 --> 00:03:19,269
how all of them have to handle the null

81
00:03:16,360 --> 00:03:22,209
values and their possibility returning

82
00:03:19,269 --> 00:03:24,430
it right every single place and then e

83
00:03:22,209 --> 00:03:26,500
pivots and says what if we check for it

84
00:03:24,430 --> 00:03:30,010
automatically right and and how do we

85
00:03:26,500 --> 00:03:31,840
how can we do that automatically does it

86
00:03:30,010 --> 00:03:35,860
use that apply function we had earlier

87
00:03:31,840 --> 00:03:39,340
right so the secret to all of this is in

88
00:03:35,860 --> 00:03:41,739
that you change how these functions are

89
00:03:39,340 --> 00:03:44,260
interpreted instead of changing those

90
00:03:41,739 --> 00:03:47,260
functions themselves that's pretty cool

91
00:03:44,260 --> 00:03:49,750
so earlier you said that apply you know

92
00:03:47,260 --> 00:03:50,739
it takes to re-take so an argument in a

93
00:03:49,750 --> 00:03:52,480
function and then it applies that

94
00:03:50,739 --> 00:03:54,220
function to that argument exactly like

95
00:03:52,480 --> 00:03:55,930
you might expect but what is it doing

96
00:03:54,220 --> 00:03:57,640
now that null has entered the picture

97
00:03:55,930 --> 00:04:01,480
that's actually where it gets to

98
00:03:57,640 --> 00:04:07,840
updating the apply function where if X

99
00:04:01,480 --> 00:04:10,120
is equal to null so give an apply X F if

100
00:04:07,840 --> 00:04:13,690
X is equal to note you just search on

101
00:04:10,120 --> 00:04:15,660
null otherwise you apply F to X that's

102
00:04:13,690 --> 00:04:19,269
pretty cool I like to think of that as

103
00:04:15,660 --> 00:04:21,070
short-circuiting where once you

104
00:04:19,269 --> 00:04:22,720
encounter a null everything stops

105
00:04:21,070 --> 00:04:23,900
happening and you just get null from

106
00:04:22,720 --> 00:04:26,240
that point out

107
00:04:23,900 --> 00:04:28,669
and I see that a lot in JavaScript

108
00:04:26,240 --> 00:04:30,350
functions where you say right at the top

109
00:04:28,669 --> 00:04:32,630
of some handler you say if some

110
00:04:30,350 --> 00:04:34,280
condition is met then return null or

111
00:04:32,630 --> 00:04:36,050
error or whatever it is and that carry

112
00:04:34,280 --> 00:04:38,060
on so this is pretty similar to that in

113
00:04:36,050 --> 00:04:41,540
my mind yeah there's just a lot of times

114
00:04:38,060 --> 00:04:43,790
where within a function you'd have to do

115
00:04:41,540 --> 00:04:44,630
a lot of nested-if checks or something

116
00:04:43,790 --> 00:04:48,260
where you could have used

117
00:04:44,630 --> 00:04:51,169
short-circuiting mm-hmm yeah it cleans

118
00:04:48,260 --> 00:04:53,870
things up a lot I think so now that he's

119
00:04:51,169 --> 00:04:55,729
got this new apply implementation that

120
00:04:53,870 --> 00:04:58,729
supports null checking what does he do

121
00:04:55,729 --> 00:05:02,990
with it he uses it to show how he can

122
00:04:58,729 --> 00:05:07,100
write the middle name function exactly

123
00:05:02,990 --> 00:05:08,960
the same way as he did in the previous

124
00:05:07,100 --> 00:05:11,810
iteration and that's pretty cool right

125
00:05:08,960 --> 00:05:14,120
that the same code can behave

126
00:05:11,810 --> 00:05:16,820
differently depending on if you need to

127
00:05:14,120 --> 00:05:18,889
handle nulls or not right it's starting

128
00:05:16,820 --> 00:05:20,449
to look a little bit like something but

129
00:05:18,889 --> 00:05:21,500
I don't know we don't want to give it a

130
00:05:20,449 --> 00:05:26,990
name yet I don't want to scare anybody

131
00:05:21,500 --> 00:05:28,099
off so after he shows this example of

132
00:05:26,990 --> 00:05:31,130
dealing with null

133
00:05:28,099 --> 00:05:32,630
he kind of pivots and walks back to the

134
00:05:31,130 --> 00:05:34,820
original example and then adds another

135
00:05:32,630 --> 00:05:36,919
I'll call it an effect but another thing

136
00:05:34,820 --> 00:05:39,110
so instead of checking for null he does

137
00:05:36,919 --> 00:05:42,050
something else which is kind of logging

138
00:05:39,110 --> 00:05:43,789
things as they happen right so that if

139
00:05:42,050 --> 00:05:46,700
you were needing to debug this function

140
00:05:43,789 --> 00:05:50,539
because you unexpectedly got a middle

141
00:05:46,700 --> 00:05:51,530
name of you know popcorn and that's that

142
00:05:50,539 --> 00:05:53,270
doesn't make sense then you want to

143
00:05:51,530 --> 00:05:54,560
figure out how you got there so these

144
00:05:53,270 --> 00:05:57,110
this logging would help you figure that

145
00:05:54,560 --> 00:06:00,190
out right right not being able to log in

146
00:05:57,110 --> 00:06:03,169
functions like this if we told people

147
00:06:00,190 --> 00:06:05,590
coming to Haskell like yeah you can't

148
00:06:03,169 --> 00:06:08,240
log that's not gonna work

149
00:06:05,590 --> 00:06:10,280
you you need to be practical you got a

150
00:06:08,240 --> 00:06:12,440
debug stuff and so how do they approach

151
00:06:10,280 --> 00:06:13,940
logging given that they're trying to

152
00:06:12,440 --> 00:06:17,090
implement these things as quote unquote

153
00:06:13,940 --> 00:06:19,880
pure functions so the first thing you do

154
00:06:17,090 --> 00:06:22,010
is functional languages avoid global

155
00:06:19,880 --> 00:06:24,710
variables to keep track of all those

156
00:06:22,010 --> 00:06:28,750
messages mmm so the first pass that that

157
00:06:24,710 --> 00:06:31,940
is modifying utility functions to handle

158
00:06:28,750 --> 00:06:33,680
erase and when you say arrays what do

159
00:06:31,940 --> 00:06:37,639
you mean what's in those arrays the

160
00:06:33,680 --> 00:06:39,919
result as well as the blog message

161
00:06:37,639 --> 00:06:42,229
right so you get back an array where the

162
00:06:39,919 --> 00:06:44,780
first thing in is the answer and

163
00:06:42,229 --> 00:06:46,310
everything else is kind of stuff that

164
00:06:44,780 --> 00:06:48,680
happened along the way that you might be

165
00:06:46,310 --> 00:06:51,439
interested in you might throw away right

166
00:06:48,680 --> 00:06:53,780
the trouble is that then your functions

167
00:06:51,439 --> 00:06:55,669
have to know how to handle that yeah

168
00:06:53,780 --> 00:06:58,009
every single function you call would

169
00:06:55,669 --> 00:07:00,650
need to like D structure or lookup or

170
00:06:58,009 --> 00:07:02,090
whatever but fortunately we have a

171
00:07:00,650 --> 00:07:03,710
function that we've thrown in our own

172
00:07:02,090 --> 00:07:06,530
way here right that we can change yet

173
00:07:03,710 --> 00:07:08,689
again to do what need here right that

174
00:07:06,530 --> 00:07:12,080
that pointless seeming function from at

175
00:07:08,689 --> 00:07:15,860
first apply which made things look all

176
00:07:12,080 --> 00:07:18,469
horrible now like oh we can just go back

177
00:07:15,860 --> 00:07:21,439
and modify this now 2d structure that

178
00:07:18,469 --> 00:07:22,250
and and show us what the logs the

179
00:07:21,439 --> 00:07:25,039
results up

180
00:07:22,250 --> 00:07:27,259
yeah previously we were using the supply

181
00:07:25,039 --> 00:07:29,779
function to check for null but now we're

182
00:07:27,259 --> 00:07:32,419
saying grab that first thing out of it

183
00:07:29,779 --> 00:07:33,770
and append all you know can cat together

184
00:07:32,419 --> 00:07:35,629
all the other stuff so we're

185
00:07:33,770 --> 00:07:37,340
accumulating these log messages as we go

186
00:07:35,629 --> 00:07:39,169
through but still producing the result

187
00:07:37,340 --> 00:07:40,939
that we wanted in the first place yeah

188
00:07:39,169 --> 00:07:43,039
and that's that's really cool to be able

189
00:07:40,939 --> 00:07:44,180
to just modify that apply again to

190
00:07:43,039 --> 00:07:46,789
handle all our needs

191
00:07:44,180 --> 00:07:49,370
exactly pretty nice again you end up

192
00:07:46,789 --> 00:07:51,379
with the same shape at the top level it

193
00:07:49,370 --> 00:07:53,960
still looks exactly the same but

194
00:07:51,379 --> 00:07:56,150
underneath the covers the implementing

195
00:07:53,960 --> 00:07:57,650
the implementation details are kind of

196
00:07:56,150 --> 00:07:59,089
switched out from underneath you so

197
00:07:57,650 --> 00:08:01,460
instead of handling Knolls now we're

198
00:07:59,089 --> 00:08:04,190
doing logging and that's that does

199
00:08:01,460 --> 00:08:07,909
that's why this blog post does a really

200
00:08:04,190 --> 00:08:11,659
good job of motivating why the word

201
00:08:07,909 --> 00:08:12,919
we're not saying as useful maybe at this

202
00:08:11,659 --> 00:08:16,129
point we can start talking about it is

203
00:08:12,919 --> 00:08:17,509
in the title after all so oh yeah so far

204
00:08:16,129 --> 00:08:20,000
these have been two examples of

205
00:08:17,509 --> 00:08:22,189
Manette's and this is showing you that

206
00:08:20,000 --> 00:08:23,810
yeah they are useful for real-life

207
00:08:22,189 --> 00:08:26,060
situations that you're gonna come across

208
00:08:23,810 --> 00:08:28,310
as you're writing programs it's not just

209
00:08:26,060 --> 00:08:31,009
you know advanced math ivory tower stuff

210
00:08:28,310 --> 00:08:33,229
for sure there's a lot of it a lot of

211
00:08:31,009 --> 00:08:35,180
real-world advantages that you get from

212
00:08:33,229 --> 00:08:37,669
on ads and these were good examples

213
00:08:35,180 --> 00:08:39,560
already mm-hm and they go on to give a

214
00:08:37,669 --> 00:08:42,469
few more so so let's kind of get through

215
00:08:39,560 --> 00:08:43,940
those they talk about global environment

216
00:08:42,469 --> 00:08:45,920
which when I read that makes me shudder

217
00:08:43,940 --> 00:08:47,149
a little bit because I don't like global

218
00:08:45,920 --> 00:08:49,040
environments I like things to be as

219
00:08:47,149 --> 00:08:51,290
local as possible but I think they don't

220
00:08:49,040 --> 00:08:54,230
really mean global they mean some

221
00:08:51,290 --> 00:08:56,889
else don't they it's kind of like scoped

222
00:08:54,230 --> 00:09:01,100
to the function or something like that

223
00:08:56,889 --> 00:09:03,019
right they mean for a given function you

224
00:09:01,100 --> 00:09:06,980
can provide an environment that can be

225
00:09:03,019 --> 00:09:08,480
modified within that scope right so the

226
00:09:06,980 --> 00:09:10,339
way that I like to think about this and

227
00:09:08,480 --> 00:09:13,540
I think this actually came up in our

228
00:09:10,339 --> 00:09:16,040
code base recently here at work where we

229
00:09:13,540 --> 00:09:19,790
had a series of functions that all

230
00:09:16,040 --> 00:09:21,620
needed some config and we were passing

231
00:09:19,790 --> 00:09:25,009
that config from functionary to function

232
00:09:21,620 --> 00:09:26,329
B B to C C to D and that's a lot of

233
00:09:25,009 --> 00:09:29,029
boilerplate because you have to thread

234
00:09:26,329 --> 00:09:31,370
that thing all the way through and I

235
00:09:29,029 --> 00:09:32,420
think we we came out of that not having

236
00:09:31,370 --> 00:09:37,420
to thread it through can you tell us how

237
00:09:32,420 --> 00:09:40,880
we got there right so we started using a

238
00:09:37,420 --> 00:09:43,639
mana transformer which the important

239
00:09:40,880 --> 00:09:44,500
thing is that it had a reader mana in it

240
00:09:43,639 --> 00:09:49,670
mm-hmm

241
00:09:44,500 --> 00:09:54,019
Damona is what that just means that you

242
00:09:49,670 --> 00:09:56,029
can simply use a function called ask and

243
00:09:54,019 --> 00:09:57,649
whatever you initiated that reader

244
00:09:56,029 --> 00:09:59,959
bonad with whatever value it was

245
00:09:57,649 --> 00:10:04,250
initiated with you'll get that back in

246
00:09:59,959 --> 00:10:05,240
our case it was convicted yeah so our we

247
00:10:04,250 --> 00:10:08,209
had all these functions that were

248
00:10:05,240 --> 00:10:09,529
operating in this maaan ad and instead

249
00:10:08,209 --> 00:10:12,050
of passing an argument through to

250
00:10:09,529 --> 00:10:14,060
everything in the single place where we

251
00:10:12,050 --> 00:10:16,550
needed it all we had to do was ask for

252
00:10:14,060 --> 00:10:19,610
it and it was suddenly available right

253
00:10:16,550 --> 00:10:22,040
actually at one point we we had both the

254
00:10:19,610 --> 00:10:25,220
new mana and we were still passing it

255
00:10:22,040 --> 00:10:26,779
thick-headed twice you know just to make

256
00:10:25,220 --> 00:10:28,069
sure get it from one place get her from

257
00:10:26,779 --> 00:10:34,550
the other make sure they're the same and

258
00:10:28,069 --> 00:10:37,220
then move on right so in in this blog

259
00:10:34,550 --> 00:10:38,540
post he shows this global environment

260
00:10:37,220 --> 00:10:40,850
example and kind of walks you through

261
00:10:38,540 --> 00:10:43,850
the the reader mine ad is what it would

262
00:10:40,850 --> 00:10:45,769
be an asshole and you know does it

263
00:10:43,850 --> 00:10:47,480
provides motivation for this example

264
00:10:45,769 --> 00:10:50,240
that we just ran into passing all these

265
00:10:47,480 --> 00:10:51,740
arguments is annoying and if you can put

266
00:10:50,240 --> 00:10:52,220
it in your context and then escort when

267
00:10:51,740 --> 00:10:54,380
you need it

268
00:10:52,220 --> 00:10:56,990
it's pretty nice and once again as you

269
00:10:54,380 --> 00:10:59,779
might be able to guess you change apply

270
00:10:56,990 --> 00:11:01,069
and your actual business logic ends up

271
00:10:59,779 --> 00:11:02,480
looking the same and all the stuff

272
00:11:01,069 --> 00:11:04,130
underneath the covers kind of changes

273
00:11:02,480 --> 00:11:06,110
out from underneath you which sounds

274
00:11:04,130 --> 00:11:08,160
scary but promise

275
00:11:06,110 --> 00:11:10,949
as long as you follow a few rules

276
00:11:08,160 --> 00:11:15,149
exactly so they're important rules say

277
00:11:10,949 --> 00:11:16,290
that we call them laws but I don't think

278
00:11:15,149 --> 00:11:18,649
you get arrested if you don't follow

279
00:11:16,290 --> 00:11:21,779
them it's just very a very frowned upon

280
00:11:18,649 --> 00:11:25,050
so now that we've gone through dealing

281
00:11:21,779 --> 00:11:26,850
with nulls accumulating a bunch of state

282
00:11:25,050 --> 00:11:28,759
in this case logs as we go through stuff

283
00:11:26,850 --> 00:11:30,420
and having a kind of read-only

284
00:11:28,759 --> 00:11:32,100
environment that's available to our

285
00:11:30,420 --> 00:11:34,759
functions we land on the final example

286
00:11:32,100 --> 00:11:37,350
which is state which is something that

287
00:11:34,759 --> 00:11:40,139
gets passed to every function but also

288
00:11:37,350 --> 00:11:41,699
can be updated along the way can you

289
00:11:40,139 --> 00:11:43,350
tell us a little more about this example

290
00:11:41,699 --> 00:11:46,050
and kind of how it differs from the

291
00:11:43,350 --> 00:11:49,490
previous ones it's really similar like

292
00:11:46,050 --> 00:11:52,170
you're saying I think to the reader mana

293
00:11:49,490 --> 00:11:54,779
the only difference is that that initial

294
00:11:52,170 --> 00:11:59,370
state that was passed in you can update

295
00:11:54,779 --> 00:12:00,300
it then you can you can get it again do

296
00:11:59,370 --> 00:12:02,550
whatever you want with it

297
00:12:00,300 --> 00:12:03,959
mm-hm and I think the example they use

298
00:12:02,550 --> 00:12:06,420
as kind of motivation has to deal with

299
00:12:03,959 --> 00:12:08,310
random numbers because if you want to

300
00:12:06,420 --> 00:12:10,230
generate a bunch of random numbers in a

301
00:12:08,310 --> 00:12:11,899
pure fashion without reading from like

302
00:12:10,230 --> 00:12:13,709
/dev view random or something like that

303
00:12:11,899 --> 00:12:16,529
typically you're going to need a random

304
00:12:13,709 --> 00:12:17,850
number of seed and those are

305
00:12:16,529 --> 00:12:19,199
deterministic so if you give something

306
00:12:17,850 --> 00:12:22,709
the same seed you get back the same

307
00:12:19,199 --> 00:12:24,449
answer which works fine if you only need

308
00:12:22,709 --> 00:12:26,309
one random number you could throw that

309
00:12:24,449 --> 00:12:28,110
in your reader context and pull out the

310
00:12:26,309 --> 00:12:30,059
seed and generate your random number but

311
00:12:28,110 --> 00:12:31,470
if you want to generate two you would

312
00:12:30,059 --> 00:12:33,209
generate the same number both times

313
00:12:31,470 --> 00:12:35,459
because you couldn't change that reader

314
00:12:33,209 --> 00:12:38,910
context so you need something like the

315
00:12:35,459 --> 00:12:41,339
state where you can ask for it or get it

316
00:12:38,910 --> 00:12:43,199
and then do whatever operation you want

317
00:12:41,339 --> 00:12:44,160
with and then put something back into

318
00:12:43,199 --> 00:12:47,490
the state change it

319
00:12:44,160 --> 00:12:49,379
I actually remember I remember having a

320
00:12:47,490 --> 00:12:51,259
bug with random numbers before where I

321
00:12:49,379 --> 00:12:53,939
might have been using a reader monitor

322
00:12:51,259 --> 00:12:56,430
just threading that same seed through

323
00:12:53,939 --> 00:12:59,370
and after I figured it out it just

324
00:12:56,430 --> 00:13:01,620
reminded me at the xkcd comic it's like

325
00:12:59,370 --> 00:13:03,689
turn 42 yeah

326
00:13:01,620 --> 00:13:05,100
guaranteed random number we rolled some

327
00:13:03,689 --> 00:13:07,079
dice and figured out this is a very

328
00:13:05,100 --> 00:13:11,129
random number we're just gonna keep

329
00:13:07,079 --> 00:13:12,660
giving it to you yeah so we don't want

330
00:13:11,129 --> 00:13:14,930
to implement random number generators

331
00:13:12,660 --> 00:13:17,150
like that and you don't have to

332
00:13:14,930 --> 00:13:19,690
the Mount add abstraction is powerful

333
00:13:17,150 --> 00:13:22,040
enough to give you this ability to

334
00:13:19,690 --> 00:13:24,260
consistently take something in into your

335
00:13:22,040 --> 00:13:25,790
environment and use it and modify it and

336
00:13:24,260 --> 00:13:30,100
then return that back out along with

337
00:13:25,790 --> 00:13:33,230
your answer so once again we end up with

338
00:13:30,100 --> 00:13:34,850
changing the apply function and using

339
00:13:33,230 --> 00:13:37,970
the same business logic over and over

340
00:13:34,850 --> 00:13:40,640
and over again so that gets us through

341
00:13:37,970 --> 00:13:43,370
all of the motivating examples that this

342
00:13:40,640 --> 00:13:44,870
guy gave for Mon ads and he managed to

343
00:13:43,370 --> 00:13:46,250
make it through this post without using

344
00:13:44,870 --> 00:13:50,720
my nads we didn't quite you know I think

345
00:13:46,250 --> 00:13:52,730
we made it halfway through but this is

346
00:13:50,720 --> 00:13:53,810
something that happens a lot in the

347
00:13:52,730 --> 00:13:56,900
Haskell community right

348
00:13:53,810 --> 00:13:59,060
beginners kind of finally grokking Mon

349
00:13:56,900 --> 00:14:03,200
ads have you seen this come up before

350
00:13:59,060 --> 00:14:06,200
oh yeah a ton I personally spread right

351
00:14:03,200 --> 00:14:11,960
maskel just by making functions with you

352
00:14:06,200 --> 00:14:14,420
know five ten arguments yeah to pass the

353
00:14:11,960 --> 00:14:15,860
state through and then I finally got I

354
00:14:14,420 --> 00:14:17,930
know I didn't up I was like I'm gonna

355
00:14:15,860 --> 00:14:21,830
learn what bonnets are about I came

356
00:14:17,930 --> 00:14:25,130
across a billion tutorials monitor

357
00:14:21,830 --> 00:14:25,850
burritos what else are they oh there are

358
00:14:25,130 --> 00:14:28,310
all kinds of things

359
00:14:25,850 --> 00:14:29,900
I see singing there straws but I think

360
00:14:28,310 --> 00:14:33,140
that's lenses are straws monitor

361
00:14:29,900 --> 00:14:37,580
burritos they're boxes they're thinners

362
00:14:33,140 --> 00:14:39,290
I don't know any number of things that's

363
00:14:37,580 --> 00:14:41,089
why I really like tutorials like this

364
00:14:39,290 --> 00:14:43,520
which focus on some real examples

365
00:14:41,089 --> 00:14:45,560
because you're not gonna you're not

366
00:14:43,520 --> 00:14:47,209
gonna get very far with metaphors as

367
00:14:45,560 --> 00:14:49,279
much as you will with using these things

368
00:14:47,209 --> 00:14:51,020
and seeing why those laws that are

369
00:14:49,279 --> 00:14:54,380
seemingly pointless why the supply of

370
00:14:51,020 --> 00:14:57,770
functions there seemed pointless help

371
00:14:54,380 --> 00:15:00,860
you yeah I agree I much prefer seeing a

372
00:14:57,770 --> 00:15:02,150
motivating example rather than here's

373
00:15:00,860 --> 00:15:06,350
the type signature and here's the laws

374
00:15:02,150 --> 00:15:07,730
and it's important and good luck walking

375
00:15:06,350 --> 00:15:09,230
through stuff like this really helps me

376
00:15:07,730 --> 00:15:12,110
or would have helped me when I was

377
00:15:09,230 --> 00:15:14,000
learning Haskell see why do I care about

378
00:15:12,110 --> 00:15:16,670
this what do I get out of it you know

379
00:15:14,000 --> 00:15:17,930
exactly and like you I've seen so many

380
00:15:16,670 --> 00:15:19,940
of these tutorials through the years

381
00:15:17,930 --> 00:15:21,830
that it feels a little bit like a rite

382
00:15:19,940 --> 00:15:23,570
of passage for new Haskell there's like

383
00:15:21,830 --> 00:15:24,860
yeah you got to learn what my nads are

384
00:15:23,570 --> 00:15:26,290
and then you got to write the blog post

385
00:15:24,860 --> 00:15:28,689
that says you look

386
00:15:26,290 --> 00:15:32,109
they are and that's exactly what's

387
00:15:28,689 --> 00:15:34,239
happened yeah somehow I think neither

388
00:15:32,109 --> 00:15:36,220
you nor I have written this blog post

389
00:15:34,239 --> 00:15:39,850
but maybe that just means we haven't

390
00:15:36,220 --> 00:15:44,489
truly understood my Nancy yet well I

391
00:15:39,850 --> 00:15:46,989
hope we're making a podcast about yeah

392
00:15:44,489 --> 00:15:48,910
does this count as a blog post probably

393
00:15:46,989 --> 00:15:51,069
anyway I think that about wraps it up

394
00:15:48,910 --> 00:15:53,609
for us today thanks for being with me on

395
00:15:51,069 --> 00:15:55,809
the show today Cody

396
00:15:53,609 --> 00:15:57,449
it was a lot of fun it's always good and

397
00:15:55,809 --> 00:16:00,039
you have good having you on here and

398
00:15:57,449 --> 00:16:01,749
thank you for listening to the haskell

399
00:16:00,039 --> 00:16:03,399
weekly podcast if you liked what you

400
00:16:01,749 --> 00:16:07,059
heard please find out more at our

401
00:16:03,399 --> 00:16:09,189
website haskell weekly dot news and if

402
00:16:07,059 --> 00:16:10,839
you did like our show again please go

403
00:16:09,189 --> 00:16:11,829
rate and review us on iTunes it helps a

404
00:16:10,839 --> 00:16:13,569
lot

405
00:16:11,829 --> 00:16:16,119
Haskell weekly is brought to you every

406
00:16:13,569 --> 00:16:17,679
week by IT pro TV the tech skills

407
00:16:16,119 --> 00:16:20,589
development platform for IT

408
00:16:17,679 --> 00:16:23,109
professionals who also happens to be our

409
00:16:20,589 --> 00:16:27,189
employer so please send your sis admins

410
00:16:23,109 --> 00:16:29,439
and network admins 2ww IT pro TV for all

411
00:16:27,189 --> 00:16:31,029
their learning needs and they can let

412
00:16:29,439 --> 00:16:33,789
you know what they think of the people

413
00:16:31,029 --> 00:16:38,100
who develop it which is us so thanks

414
00:16:33,789 --> 00:16:38,100
again Cody and we'll see y'all next week

415
00:16:39,100 --> 00:16:41,160
you
