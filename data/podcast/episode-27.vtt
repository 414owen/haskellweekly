WEBVTT

1
00:00:02.040 --> 00:00:02.250
Yeah.

2
00:00:04.840 --> 00:00:07.370
Hello and welcome to the high school Weekly

3
00:00:07.370 --> 00:00:10.290
podcast. I'm your host, Taylor Foss. AC. I'm

4
00:00:10.290 --> 00:00:13.150
the lead engineer at I t Pro TV, which is an

5
00:00:13.160 --> 00:00:16.160
e learning platform for I t. Professionals with me

6
00:00:16.160 --> 00:00:19.130
today is one of the engineers on my team. Cameron Gara.

7
00:00:19.140 --> 00:00:22.130
Welcome camp. Hey, man, how's it going? It's going

8
00:00:22.130 --> 00:00:24.900
good. Thanks for being on the show today. Of course, man.

9
00:00:24.910 --> 00:00:27.750
>> Well, you know, it's still October.

10
00:00:27.750 --> 00:00:30.520
We've been doing this podcast again for three

11
00:00:30.520 --> 00:00:33.470
weeks, and we're still in October. Which means

12
00:00:33.470 --> 00:00:36.100
we are still in hack Tober Fest,

13
00:00:36.110 --> 00:00:39.020
which is an awesome opportunity for us to contribute to the

14
00:00:39.020 --> 00:00:41.680
open source world and really just make a

15
00:00:41.680 --> 00:00:44.680
difference in these projects that may not have

16
00:00:44.690 --> 00:00:47.190
as much dev time going into them. So

17
00:00:47.200 --> 00:00:49.990
for us, it gives us a chance to learn a swell

18
00:00:49.990 --> 00:00:52.850
as contribute to these projects. Um, eso won

19
00:00:52.850 --> 00:00:55.620
awesome project. Just learn for high school, which is put on by

20
00:00:55.620 --> 00:00:58.170
Kucinich. And it's an opportunity for

21
00:00:58.240 --> 00:01:01.170
people to be a part of Octoberfest and also learn

22
00:01:01.170 --> 00:01:03.480
high school at the same time. So if you're

23
00:01:03.490 --> 00:01:06.320
interested, go check it out at learn for high

24
00:01:06.320 --> 00:01:09.190
school. I think you can Google that, um you can also check it

25
00:01:09.190 --> 00:01:12.050
out on quiet Excite. I believe they have

26
00:01:12.050 --> 00:01:14.710
some links as well, but it's a good opportunity for us

27
00:01:14.710 --> 00:01:17.450
to, you know, contribute learn high school

28
00:01:17.460 --> 00:01:20.350
and get a free T shirt. So, you know, we all love free

29
00:01:20.350 --> 00:01:21.370
T shirts around here.

30
00:01:21.640 --> 00:01:24.460
>> Sure do. I'm wearing a free T shirt right now, and it feels great.

31
00:01:24.640 --> 00:01:27.550
>> Yeah, e guess I am. I'm we're gonna work

32
00:01:27.550 --> 00:01:30.180
t shirt, which is free to me. So that's always

33
00:01:30.180 --> 00:01:33.020
nice. Yeah, awesome. Well, Taylor, what are we

34
00:01:33.020 --> 00:01:34.120
talking about today?

35
00:01:34.130 --> 00:01:36.910
>> Today we are talking about a block post by

36
00:01:36.910 --> 00:01:39.870
Chris Pinar called Silly Job interview

37
00:01:39.870 --> 00:01:42.750
Questions in Haskell If you haven't heard of

38
00:01:42.750 --> 00:01:45.350
him before. Chris Penner is the author of a

39
00:01:45.350 --> 00:01:48.340
book called Optics by example where he does

40
00:01:48.340 --> 00:01:51.080
a deep dive on optics and lenses and

41
00:01:51.080 --> 00:01:53.560
Haskell how to use them. How to get familiar with

42
00:01:53.560 --> 00:01:54.100
him.

43
00:01:54.110 --> 00:01:56.610
>> Yeah, so, you know, he kind of talks

44
00:01:56.610 --> 00:01:58.840
about, you know, the interview

45
00:01:58.850 --> 00:02:01.670
questions that are part of the interview process

46
00:02:01.940 --> 00:02:04.590
and in the interview process. If you're looking for any kind of

47
00:02:04.590 --> 00:02:07.350
job, um, you know, in the tech job in particular,

48
00:02:07.360 --> 00:02:10.000
you're gonna generally have kind of, ah, general

49
00:02:10.000 --> 00:02:12.930
interview kind of understanding who you are. You have a culture

50
00:02:12.930 --> 00:02:15.740
fit interview with kind of the team you're gonna be a part of.

51
00:02:15.750 --> 00:02:18.680
And then you'll also have a technical interview where

52
00:02:18.680 --> 00:02:21.590
you can kind of get asked and challenged

53
00:02:21.600 --> 00:02:24.350
in various ways in the various programming

54
00:02:24.350 --> 00:02:27.260
language you may be in contact with in that job role.

55
00:02:27.440 --> 00:02:30.420
Um, and so for a lot of high school jobs, you're gonna come across

56
00:02:30.420 --> 00:02:32.610
some of these high school

57
00:02:32.620 --> 00:02:35.490
problems and be able to solve them quickly If you

58
00:02:35.490 --> 00:02:38.320
kind of reviewed this block post. And, you know, I

59
00:02:38.320 --> 00:02:41.000
think he does a great job here of,

60
00:02:41.010 --> 00:02:43.620
you know, kind of giving us the general

61
00:02:43.630 --> 00:02:46.350
idea behind why he made the

62
00:02:46.350 --> 00:02:49.150
decisions he made. And a swell is like a good

63
00:02:49.140 --> 00:02:51.870
variety of the questions that you could be asked

64
00:02:52.340 --> 00:02:55.250
and yeah, just just to jump

65
00:02:55.250 --> 00:02:57.610
in the first one was the palindrome,

66
00:02:57.610 --> 00:03:00.400
which, in high school I mean, can't get any

67
00:03:00.400 --> 00:03:01.560
easier than that, Right? Taylor,

68
00:03:01.570 --> 00:03:04.450
>> you sure can't. This is this is so easy

69
00:03:04.450 --> 00:03:07.430
because all the functions you need are in the prelude, and you don't

70
00:03:07.430 --> 00:03:10.430
have to string too many of them together to get an answer. But I

71
00:03:10.430 --> 00:03:13.070
was gonna ask you, Cam, what's your favorite palindrome?

72
00:03:13.240 --> 00:03:16.240
>> Probably race car, which is, you know, kind of

73
00:03:16.240 --> 00:03:19.190
the only one I can think of at the moment. But it's in the also in the

74
00:03:19.190 --> 00:03:22.060
block post, so you know, it's a

75
00:03:22.060 --> 00:03:24.990
little bit a cop out, but I would say race cars a good one for

76
00:03:24.990 --> 00:03:26.580
me. What about you?

77
00:03:26.590 --> 00:03:29.240
>> I like Taco Cat. It's also short to the

78
00:03:29.240 --> 00:03:31.840
point. I know there are some extremely long

79
00:03:31.850 --> 00:03:34.680
palindromes, but yeah, that's that's besides the

80
00:03:34.680 --> 00:03:37.660
point. Um, so Chris shows a

81
00:03:37.660 --> 00:03:40.400
solution for the palindrome question here, which

82
00:03:40.410 --> 00:03:43.280
I guess if you're not familiar with the Palindrome, it's something that has

83
00:03:43.280 --> 00:03:46.260
the same order of letters, forwards and backwards. So

84
00:03:46.260 --> 00:03:49.000
like racecar as an example r a c

85
00:03:49.000 --> 00:03:51.470
e c a r. That goes the same forwards and

86
00:03:51.470 --> 00:03:53.930
backwards. So the way that he,

87
00:03:53.940 --> 00:03:56.620
uh, solves this problem is by

88
00:03:56.630 --> 00:03:59.350
comparing the original string with the reversed

89
00:03:59.350 --> 00:04:02.120
version of the string. And if they're equal, then it's the same forwards and

90
00:04:02.120 --> 00:04:03.380
backwards Super easy.

91
00:04:03.390 --> 00:04:05.890
>> Yep. Yep. I think that was Ah. Ah, great

92
00:04:05.890 --> 00:04:08.600
solution. Very straight to the point. Um,

93
00:04:08.600 --> 00:04:11.050
and you know, it's not bad when you could get one line of

94
00:04:11.050 --> 00:04:13.540
code solve, you know, quote unquote. The

95
00:04:13.540 --> 00:04:14.850
technical interview,

96
00:04:14.840 --> 00:04:17.760
>> Yeah, especially if you're answering this on like a white board. You know,

97
00:04:17.770 --> 00:04:20.490
if your handwriting's really bad, this one's an easy one to knock out.

98
00:04:20.500 --> 00:04:23.180
>> Yeah, and I think it does provide

99
00:04:23.190 --> 00:04:25.840
for a good ability to explain it to

100
00:04:25.850 --> 00:04:28.830
write. Uh, that's kind of the point of these technical interviews

101
00:04:28.830 --> 00:04:31.680
will be coming across, and for those who have come across it,

102
00:04:31.690 --> 00:04:34.520
you already know it's just about kind of giving your

103
00:04:34.520 --> 00:04:37.450
verbal processing out and allowing you know, the team that you're

104
00:04:37.450 --> 00:04:40.350
gonna be joining to kind of hear and understand and see how you

105
00:04:40.350 --> 00:04:43.180
solve a problem. So he kind of talks and starts

106
00:04:43.180 --> 00:04:46.120
with, you know, the easy one of the palindrome on, and then it kind

107
00:04:46.120 --> 00:04:48.650
of takes another step forward, right?

108
00:04:48.660 --> 00:04:50.350
What's the next one that he talks about?

109
00:04:50.740 --> 00:04:53.710
>> The next question is fizz buzz, and I'm sure a

110
00:04:53.710 --> 00:04:56.670
lot of people are already nodding along because they're familiar with this

111
00:04:56.670 --> 00:04:59.010
one. But if you haven't haven't heard of it

112
00:04:59.010 --> 00:05:01.730
before, the question is where the problem is to

113
00:05:01.730 --> 00:05:04.350
print out the 1st 100 numbers, so one through

114
00:05:04.350 --> 00:05:07.290
100. But if the number is divisible by

115
00:05:07.290 --> 00:05:09.970
three, you print out the string fizz,

116
00:05:10.150 --> 00:05:13.050
and if it's divisible by five, you print out buzz.

117
00:05:13.440 --> 00:05:16.300
And if it's divisible by both you print out fizz

118
00:05:16.300 --> 00:05:18.910
buzz. So pretty simple problem.

119
00:05:18.910 --> 00:05:21.370
But a surprising number of candidates

120
00:05:21.380 --> 00:05:24.160
can't answer this one. So it's good to see a Haskell solution

121
00:05:24.160 --> 00:05:24.450
here.

122
00:05:24.940 --> 00:05:27.920
>> Yeah, it definitely like when you hear the explanation. It kind of can

123
00:05:27.920 --> 00:05:30.830
make you squirm a little bit. But if you really listen

124
00:05:30.830 --> 00:05:33.770
to the problem, what it's asking, it's not too bad.

125
00:05:33.770 --> 00:05:36.690
And you just gotta, I think with every big problem you got

126
00:05:36.690 --> 00:05:39.450
to solve or any problem you have to solve, you know, you just gotta take one

127
00:05:39.450 --> 00:05:42.370
step at a time, you know, figure out all right, what do I need to

128
00:05:42.370 --> 00:05:45.320
do first? And then you can build on that, And I think high school

129
00:05:46.140 --> 00:05:49.050
kind of allows you to do that pretty well on day for

130
00:05:49.050 --> 00:05:51.560
his solution. He actually takes some time to use

131
00:05:51.560 --> 00:05:54.560
guards, which, if you aren't familiar with guards, you know,

132
00:05:54.560 --> 00:05:57.310
they're kind of a, you know, in line pattern matching per

133
00:05:57.310 --> 00:06:00.220
se, um, and that allow you to,

134
00:06:00.230 --> 00:06:02.820
you know, do some comparison check.

135
00:06:02.830 --> 00:06:05.220
And, you know, if it equals

136
00:06:05.230 --> 00:06:07.850
true, then you about you go

137
00:06:07.860 --> 00:06:10.740
proceed to that line of code. Um, and so here

138
00:06:10.740 --> 00:06:13.690
he kind of, you know, goes one step at a time with, you

139
00:06:13.690 --> 00:06:16.510
know, some sort of secondary function that he's gonna iterate over.

140
00:06:16.520 --> 00:06:19.190
You know, this list of 1 to 100 with that? He

141
00:06:19.190 --> 00:06:22.180
does, you know, a check of, you know, the number of

142
00:06:22.180 --> 00:06:24.900
mod three. And number five. If those both equals

143
00:06:24.900 --> 00:06:27.780
zero, then he prints out fizz buzz. If not, you know,

144
00:06:27.780 --> 00:06:30.650
he goes the next case, which the next case, he's doing the

145
00:06:30.840 --> 00:06:33.720
mod three check. So if mod three of that number

146
00:06:33.720 --> 00:06:36.270
equals zero, then it's gonna print out fizz.

147
00:06:36.840 --> 00:06:39.380
Same with five when he's gonna print out Buzz.

148
00:06:39.390 --> 00:06:41.670
So you know, he's got these

149
00:06:41.680 --> 00:06:44.340
cases that if they

150
00:06:44.340 --> 00:06:47.280
evaluated, true that, that's what is returned. If

151
00:06:47.280 --> 00:06:50.140
not, none of those cases returned. True, he's just gonna

152
00:06:50.140 --> 00:06:52.860
print out that number. And so it's

153
00:06:52.860 --> 00:06:55.720
pretty straightforward. Um, one interesting thing, though

154
00:06:55.720 --> 00:06:58.600
Taylor is that he decided to use for

155
00:06:58.600 --> 00:07:01.380
underscore from data dot foldable. Where? For

156
00:07:01.380 --> 00:07:04.110
me? I would have probably used just map out of

157
00:07:04.110 --> 00:07:07.060
Prelude. Um, that doesn't you know, it's

158
00:07:07.060 --> 00:07:09.570
pretty much the same as four underscore, but with

159
00:07:09.680 --> 00:07:11.860
reversed arguments, right?

160
00:07:12.440 --> 00:07:15.140
>> Yeah, In fact, four is defined as

161
00:07:15.140 --> 00:07:17.980
flip map. So the fact that he reached for

162
00:07:17.980 --> 00:07:20.860
four here suggests to me that he's trying to reach out to

163
00:07:20.860 --> 00:07:23.460
an audience that may not be familiar with Haskell to write code that

164
00:07:23.460 --> 00:07:26.160
looks a little more imperative, even though, really, behind the

165
00:07:26.160 --> 00:07:29.100
scenes. It's still that functional goodness that we we

166
00:07:29.100 --> 00:07:32.040
all know and love, Um, and a quick note on what you were talking about

167
00:07:32.040 --> 00:07:34.370
with the guards. One of things that's really great about them is they

168
00:07:34.370 --> 00:07:37.030
match top to bottom. So, like you were saying, you

169
00:07:37.030 --> 00:07:39.970
can process thes and you add

170
00:07:39.970 --> 00:07:42.920
the cases that you go by and you can think, Okay, I'll start with mod

171
00:07:42.920 --> 00:07:45.890
three and then mod 50 wait. I forgot about mod three and five, So

172
00:07:45.890 --> 00:07:48.800
I'll go put that one at the top. So it's just like an if else chain

173
00:07:48.810 --> 00:07:50.870
in a regular imperative programming language.

174
00:07:51.240 --> 00:07:54.240
>> Yep. And I think a lot of these functions, you know, as we

175
00:07:54.240 --> 00:07:56.970
continue to talk about them, you know, would be good for

176
00:07:56.970 --> 00:07:59.940
people to kind of go and reason about yourself and try to solve

177
00:07:59.940 --> 00:08:02.750
it. Uh, maybe even before reading this black post

178
00:08:02.750 --> 00:08:05.540
to just kind of see if you can solve it. Obviously, we're

179
00:08:05.540 --> 00:08:08.100
talking about it here. So you have a general idea of maybe what? To

180
00:08:08.100 --> 00:08:10.940
dio, But it could be good to kind of just put that

181
00:08:10.940 --> 00:08:13.870
into practice, Um, and just kind of create that

182
00:08:13.880 --> 00:08:16.840
quick little solution, um, that you can kind

183
00:08:16.840 --> 00:08:19.800
of just have in your back pocket. So he then

184
00:08:19.800 --> 00:08:22.680
moves on, obviously to, um, something

185
00:08:22.680 --> 00:08:25.650
else, Something else. Even more complicated. And he

186
00:08:25.660 --> 00:08:28.330
it's called some up to end numbers,

187
00:08:28.340 --> 00:08:31.270
which when I first passed over

188
00:08:31.270 --> 00:08:34.270
it, I was like, Okay, like, I get that. I wasn't

189
00:08:34.270 --> 00:08:37.270
sure how he reasoned about, You know, obviously, I

190
00:08:37.270 --> 00:08:39.930
have to read the full question. That's part of solving these

191
00:08:39.930 --> 00:08:42.650
problems. You know, you have to read the full question.

192
00:08:42.660 --> 00:08:45.560
Um, after my second passed, I realized,

193
00:08:45.570 --> 00:08:48.550
you know, it's always just a combination of three letters or

194
00:08:48.560 --> 00:08:51.150
no letters. Numbers. I mean, numbers,

195
00:08:51.540 --> 00:08:54.270
right. And that is

196
00:08:54.640 --> 00:08:57.640
I was like, OK, cool. I'm gonna be taking a list of numbers

197
00:08:57.650 --> 00:09:00.450
and trying to find a combination of three numbers

198
00:09:00.450 --> 00:09:02.830
that equal some total, some

199
00:09:02.830 --> 00:09:05.300
specific total. Um, And

200
00:09:05.300 --> 00:09:08.050
so you know, if I'm gonna kind of attack this

201
00:09:08.050 --> 00:09:10.880
problem before we move on to the solution like I'm gonna think.

202
00:09:10.890 --> 00:09:13.860
Okay, I've got a list of numbers

203
00:09:14.240 --> 00:09:17.070
and I need to find all the combinations

204
00:09:17.080 --> 00:09:19.990
of all combinations of

205
00:09:19.990 --> 00:09:22.730
these numbers that include three, right.

206
00:09:22.740 --> 00:09:25.510
So I need to chunk them into groups of three

207
00:09:25.520 --> 00:09:28.430
and every combination of that. And so

208
00:09:28.430 --> 00:09:31.020
that's kind of what I would attack first,

209
00:09:31.030 --> 00:09:33.570
Which I think he actually ended up tackling us

210
00:09:33.570 --> 00:09:36.520
Well, on, then I would have come back and, you know,

211
00:09:36.520 --> 00:09:39.460
tried toe iterating over that new list

212
00:09:39.470 --> 00:09:42.290
of list and fine, you know, find the sum of

213
00:09:42.290 --> 00:09:45.010
each list and see if it equals the total which

214
00:09:45.010 --> 00:09:47.560
actually ends up being what he he does.

215
00:09:47.570 --> 00:09:50.530
Eso it sounds like I'm just copping out here

216
00:09:50.530 --> 00:09:53.340
and, you know, using his solution. But when I first read the

217
00:09:53.340 --> 00:09:55.940
problem, I didn't look at the solution, and that's kind of my

218
00:09:55.940 --> 00:09:58.790
process, uh, that I was would have proceeded

219
00:09:58.790 --> 00:10:01.780
with, but obviously he has a solution right there. So

220
00:10:01.780 --> 00:10:04.260
I just kept reading. And there it waas.

221
00:10:04.270 --> 00:10:07.130
>> Yeah, that's a good solution to this problem because you're breaking it

222
00:10:07.130 --> 00:10:09.640
down into components, and I think that's

223
00:10:09.640 --> 00:10:12.310
starting with the more complicated component.

224
00:10:12.320 --> 00:10:15.280
Namely, coming up with the combinations of the elements of the

225
00:10:15.280 --> 00:10:18.150
input list is a good way to go because the second part

226
00:10:18.340 --> 00:10:21.330
of figuring out if a list sums to

227
00:10:21.330 --> 00:10:24.320
some particular number and then including or excluding it based

228
00:10:24.320 --> 00:10:27.270
on that is pretty easy. So, you know, once you've

229
00:10:27.270 --> 00:10:29.940
got that nice head of steam built up from doing this

230
00:10:29.940 --> 00:10:32.800
hard combination stuff, then you finish it off

231
00:10:32.800 --> 00:10:35.790
with a nice and easy desert of just figuring out if these add up to the right

232
00:10:35.790 --> 00:10:36.100
thing.

233
00:10:36.110 --> 00:10:38.940
>> Yeah, an interesting thing. And, you know, high school

234
00:10:38.940 --> 00:10:41.240
is there is something called

235
00:10:41.240 --> 00:10:43.580
permutations, um, a function called

236
00:10:43.580 --> 00:10:46.480
permutations that will take a list and give you all of its

237
00:10:46.480 --> 00:10:48.580
permutations. But that's not quite the

238
00:10:48.580 --> 00:10:51.470
combinations. And, you know, if you look

239
00:10:51.480 --> 00:10:53.980
in package or Google for

240
00:10:53.980 --> 00:10:56.780
combinations, you're probably not gonna find one

241
00:10:56.790 --> 00:10:59.650
in, you know, a standard library. You may find one in

242
00:10:59.650 --> 00:11:02.460
some specialized package, but you know

243
00:11:02.460 --> 00:11:05.270
there's not going to generally be an easy

244
00:11:05.280 --> 00:11:08.080
combinations function you could reach for. And so he

245
00:11:08.080 --> 00:11:10.930
takes the time here and kind of explains and

246
00:11:10.940 --> 00:11:13.780
how he would have created a combinations

247
00:11:13.780 --> 00:11:16.430
function. Uh, you know, obviously, Rikers in is a

248
00:11:16.430 --> 00:11:19.200
big thing, you know, functions calling themselves

249
00:11:19.200 --> 00:11:22.140
until they find the solution and then returning that solution. It

250
00:11:22.140 --> 00:11:25.090
was nice to see all these. You know, this solution. He has very good

251
00:11:25.090 --> 00:11:28.070
comments and stuff like that. Uh, but could

252
00:11:28.070 --> 00:11:30.930
you kind of explain a little bit more on, like, what's happening in

253
00:11:30.930 --> 00:11:32.810
this combinations function?

254
00:11:32.820 --> 00:11:35.750
>> Sure. So this whole problem is

255
00:11:35.750 --> 00:11:38.380
quite a bit more complicated than the fizz buzz one and the

256
00:11:38.380 --> 00:11:41.150
combinations. Part of it, like I mentioned earlier, is definitely the

257
00:11:41.150 --> 00:11:43.360
more complicated sub problem.

258
00:11:43.840 --> 00:11:46.610
But when you break it down into the

259
00:11:46.620 --> 00:11:49.600
three kind of base cases you have to cover,

260
00:11:49.610 --> 00:11:52.450
it turns out to be surprisingly simple. So

261
00:11:52.940 --> 00:11:55.850
the combinations function as he's given it

262
00:11:55.860 --> 00:11:58.630
gives you, or it takes a number

263
00:11:58.640 --> 00:12:01.270
as of like, how many things to

264
00:12:01.270 --> 00:12:04.270
include per group. And then it takes your input list with

265
00:12:04.270 --> 00:12:07.120
all of the things in it, and you output a list of lists. So a

266
00:12:07.120 --> 00:12:09.860
list of combinations of things. And,

267
00:12:10.240 --> 00:12:13.170
as is typical with implementing recursive

268
00:12:13.170 --> 00:12:16.090
functions, you start with the base case. So the base cases you're asking

269
00:12:16.090 --> 00:12:19.000
for zero things. There's exactly one way

270
00:12:19.000 --> 00:12:21.960
to give you zero things. So you return a list

271
00:12:21.970 --> 00:12:24.150
with the empty list as it's only element,

272
00:12:25.440 --> 00:12:28.340
and then we'll gloss over the recursive call for right

273
00:12:28.340 --> 00:12:31.320
now. But the other base case is where

274
00:12:31.330 --> 00:12:34.030
you're asking for a combination of some

275
00:12:34.030 --> 00:12:36.770
number of things. But your input list is

276
00:12:36.770 --> 00:12:39.300
empty, and in that case you cannot provide any

277
00:12:39.300 --> 00:12:42.300
combination. So you return the empty list. So those

278
00:12:42.300 --> 00:12:45.280
two base cases under our belt it's pretty easy then, to

279
00:12:45.280 --> 00:12:47.850
go on to the, um, recursive

280
00:12:47.850 --> 00:12:50.440
step where what you're doing is

281
00:12:50.450 --> 00:12:53.360
grabbing one element off the front of that

282
00:12:53.360 --> 00:12:56.250
list and cons

283
00:12:56.250 --> 00:12:58.770
ing it. So like making it the first element of,

284
00:12:59.340 --> 00:13:02.280
uh, the recursive call onto the rest of the

285
00:13:02.280 --> 00:13:05.110
list for one less elements. So let's say you're looking

286
00:13:05.110 --> 00:13:07.930
out to a list of two elements, and you grab the first

287
00:13:07.930 --> 00:13:10.890
one and then for every other element, enlist you

288
00:13:10.900 --> 00:13:13.850
or every other combination of the list. Rather, you add that element

289
00:13:13.850 --> 00:13:16.790
onto the front, um, and then in

290
00:13:16.790 --> 00:13:19.730
addition to that, you do another recursive call.

291
00:13:19.730 --> 00:13:22.550
So this combinations function every

292
00:13:22.550 --> 00:13:25.500
step. It calls itself twice. So it's

293
00:13:25.510 --> 00:13:28.150
very recursive. Um, yeah,

294
00:13:28.160 --> 00:13:31.150
it's It's a little difficult to just explain without looking at the

295
00:13:31.150 --> 00:13:33.930
code. But again, with recursive

296
00:13:33.930 --> 00:13:36.660
functions, it's important to focus on those base cases. And

297
00:13:36.660 --> 00:13:39.590
then, uh, the recursive step will hopefully be clearer

298
00:13:39.590 --> 00:13:41.460
because you want to get to those base cases.

299
00:13:42.140 --> 00:13:45.130
>> Nice. Awesome. Well, I appreciate you taking that time. Yeah. Like like you

300
00:13:45.130 --> 00:13:47.920
said, it's a little hard to explain code that's

301
00:13:47.920 --> 00:13:50.810
written because, you know, it's a little easier just to

302
00:13:50.810 --> 00:13:53.450
see it and kind of process that way. But,

303
00:13:53.940 --> 00:13:56.910
you know, a classic thing that happens in

304
00:13:56.910 --> 00:13:59.760
these technical interviews is they say

305
00:13:59.770 --> 00:14:02.560
Okay, well, now this part's gonna change

306
00:14:02.940 --> 00:14:05.820
and, you know, say, for this function, we want

307
00:14:05.830 --> 00:14:08.730
all combinations of any length which some

308
00:14:08.740 --> 00:14:10.980
to the target number, you know?

309
00:14:10.990 --> 00:14:13.890
What are you going to do there? What? What's gonna have to

310
00:14:13.890 --> 00:14:16.870
change in our current implementation to make

311
00:14:16.870 --> 00:14:19.780
this work right? I mean, we're in high school. So is there something

312
00:14:19.790 --> 00:14:22.520
fun and easy and quick we can do to make this work?

313
00:14:22.530 --> 00:14:25.450
>> I don't know. If it were me, I would probably be scrambling in the

314
00:14:25.450 --> 00:14:28.160
interview. And I would just say, Take the length of the input

315
00:14:28.160 --> 00:14:30.770
list and call combinations for each

316
00:14:30.780 --> 00:14:33.200
zero up to that length. And then, boom, you've got all the

317
00:14:33.200 --> 00:14:36.190
combinations. Did you have something else in mind? No,

318
00:14:36.190 --> 00:14:39.100
that's perfect, because that's the answer. Alright. I

319
00:14:39.100 --> 00:14:39.650
passed

320
00:14:40.340 --> 00:14:43.240
>> nice through that one through that one at you, man. You

321
00:14:43.240 --> 00:14:46.120
weren't quite ready for it. But, you know, I think you figured you could handle it.

322
00:14:46.130 --> 00:14:47.270
You're pretty. Live in your feet.

323
00:14:47.740 --> 00:14:50.710
>> I think we've got a good handle on that question. Should we move on to the

324
00:14:50.710 --> 00:14:51.340
next one?

325
00:14:51.350 --> 00:14:54.060
>> I'd say so. Yeah. Why not? So we've

326
00:14:54.060 --> 00:14:56.340
got check if two strings

327
00:14:56.350 --> 00:14:58.060
are anagrams.

328
00:14:58.940 --> 00:15:00.930
Oh, anagrams.

329
00:15:00.940 --> 00:15:02.470
>> And what is an anagram? I

330
00:15:02.470 --> 00:15:03.470
>> don't know. What's an anagram?

331
00:15:04.240 --> 00:15:06.850
Actually, I believe it's

332
00:15:06.860 --> 00:15:09.500
two words that have the same

333
00:15:09.500 --> 00:15:11.790
letters. Um, I right. Or am I right?

334
00:15:11.800 --> 00:15:14.170
>> I think you're right. But there's

335
00:15:14.170 --> 00:15:16.900
additional wrinkle there where they have to have the same

336
00:15:16.900 --> 00:15:19.790
number of the same letters. So, like, you know, if

337
00:15:19.800 --> 00:15:22.660
it has to s is in it, you gotta have two s is you can't just

338
00:15:22.660 --> 00:15:23.650
have an s

339
00:15:23.840 --> 00:15:26.810
>> see Okay. Yeah, that that definitely is a little bit

340
00:15:26.810 --> 00:15:29.780
of a wrinkle. But yet again, Haskell

341
00:15:29.780 --> 00:15:32.680
comes to the rescue. In my opinion, I think it's,

342
00:15:32.680 --> 00:15:35.680
ah, quite a pleasant solution.

343
00:15:35.680 --> 00:15:38.650
They're here. They're here that he created that actually ended

344
00:15:38.650 --> 00:15:41.650
up only being two lines of code A type signature

345
00:15:42.040 --> 00:15:43.570
and a function definition.

346
00:15:44.140 --> 00:15:47.090
>> Yeah, it's very short. And it's similar to the palindrome

347
00:15:47.090 --> 00:15:49.570
question. You know, the first one. Because

348
00:15:49.580 --> 00:15:52.460
everything we need Well, we could solve this

349
00:15:52.460 --> 00:15:55.420
using just the prelude, but he actually reaches for this

350
00:15:55.420 --> 00:15:58.370
nice higher order function that's available from the data

351
00:15:58.370 --> 00:16:00.920
dot function module. And the function is called

352
00:16:00.930 --> 00:16:03.880
on, and it lets you take a binary

353
00:16:03.880 --> 00:16:06.050
function in this case equals

354
00:16:06.440 --> 00:16:09.270
and apply it by first applying another

355
00:16:09.270 --> 00:16:12.270
function to both arguments and then applying that operator. So in

356
00:16:12.270 --> 00:16:15.240
this case, we're calling equals. But before we do that, we wanna call

357
00:16:15.240 --> 00:16:18.210
sort on both of our arguments. And why is it that we wanna

358
00:16:18.210 --> 00:16:19.190
call sort camp?

359
00:16:19.200 --> 00:16:21.970
>> Well, because obviously we want to get those

360
00:16:21.980 --> 00:16:24.190
letters to be in the same order and then do a

361
00:16:24.190 --> 00:16:26.500
comparison of those lists,

362
00:16:26.740 --> 00:16:29.720
right? And if those lister equal we returned

363
00:16:29.720 --> 00:16:32.460
true. If not, we bail out. And the

364
00:16:32.470 --> 00:16:35.380
awesome thing about high school, too, is that because it's

365
00:16:35.380 --> 00:16:38.380
lazy, as soon as it finds a case where it's no longer

366
00:16:38.380 --> 00:16:41.310
equal, these two lists are no longer equal. It bails

367
00:16:41.310 --> 00:16:44.080
out, so that saves you a little bit on. You know,

368
00:16:44.090 --> 00:16:46.990
the performance issue on Do you know this

369
00:16:46.990 --> 00:16:49.430
isn't necessarily the most performance code

370
00:16:49.440 --> 00:16:52.370
anyone's ever written, but it definitely will solve

371
00:16:52.370 --> 00:16:55.110
the problem in a pinch. Um, you know,

372
00:16:55.110 --> 00:16:58.090
because obviously, sorting a list isn't

373
00:16:58.090 --> 00:17:00.460
the most effective

374
00:17:00.840 --> 00:17:03.700
way too well. It's in a very

375
00:17:03.700 --> 00:17:06.410
effective way to do comparisons of something,

376
00:17:06.410 --> 00:17:09.350
something that can be considered a list. But it also

377
00:17:09.360 --> 00:17:12.220
has a bigger notation of in

378
00:17:12.220 --> 00:17:14.890
log, in which it's a little longer

379
00:17:14.890 --> 00:17:16.770
than you know some people want to deal with.

380
00:17:17.240 --> 00:17:20.120
>> This is something people often point to as a upside of

381
00:17:20.120 --> 00:17:22.590
laziness by default, where you can have

382
00:17:22.600 --> 00:17:25.500
a sort function that lazily produces

383
00:17:25.500 --> 00:17:27.790
its output and some other function that

384
00:17:27.790 --> 00:17:30.530
lazily consumes its input,

385
00:17:30.540 --> 00:17:33.460
and the sort function is only going to do as much

386
00:17:33.460 --> 00:17:36.240
work as is required to give

387
00:17:36.240 --> 00:17:39.050
enough stuff to that other function to use. So in this

388
00:17:39.050 --> 00:17:41.770
case, equals is the function that's consuming the output of

389
00:17:41.770 --> 00:17:44.730
sort. So if on the very first letter equals says,

390
00:17:44.730 --> 00:17:47.700
well, these aren't the same, then we're not an anagram. So I'm just going

391
00:17:47.700 --> 00:17:50.700
to stop there. Sort isn't gonna bother sorting

392
00:17:50.700 --> 00:17:53.670
the entire rest of the list. Uh, it

393
00:17:53.670 --> 00:17:56.370
might, depending on the shape of the input list and everything, but in

394
00:17:56.370 --> 00:17:59.240
general, it probably won't. So that that's super nice. You don't have to

395
00:17:59.240 --> 00:18:02.160
do any fancy, like early return type stuff or anything like

396
00:18:02.160 --> 00:18:03.460
that. It just It just does it.

397
00:18:04.340 --> 00:18:07.160
>> So nice. So nice. Um, well, yeah.

398
00:18:07.170 --> 00:18:09.960
Cool. Well, the solution that he kind of

399
00:18:09.960 --> 00:18:12.800
links to that was the inspiration for this question.

400
00:18:12.810 --> 00:18:15.770
Yeah, some java solution. That was

401
00:18:16.240 --> 00:18:18.990
ah, lot of lines of code. Um, you know,

402
00:18:18.990 --> 00:18:21.480
and and, you know, he mentions here. He doesn't

403
00:18:21.480 --> 00:18:24.320
know which ones faster. Um, you know, he

404
00:18:24.320 --> 00:18:26.940
imagines the Java ones probably faster because of some of the

405
00:18:26.940 --> 00:18:29.660
considerations they did, but he's didn't

406
00:18:29.670 --> 00:18:31.970
benchmark them, so he doesn't really know.

407
00:18:31.980 --> 00:18:34.780
Um, so I mean, could be curious to

408
00:18:34.780 --> 00:18:37.380
see if lazy high school

409
00:18:37.380 --> 00:18:39.980
evaluation, you know, allows for the

410
00:18:39.980 --> 00:18:42.910
same benchmarks. Um, that

411
00:18:42.910 --> 00:18:45.540
he you know, he that would come from this job. A solution

412
00:18:45.540 --> 00:18:47.870
that is mentioned. Um

413
00:18:48.540 --> 00:18:51.230
well, cool. Yeah, I think that kind of wraps up anagram

414
00:18:51.230 --> 00:18:53.850
problem pretty, pretty cleanly

415
00:18:54.240 --> 00:18:56.160
and allows us to, you know,

416
00:18:56.840 --> 00:18:59.580
know how toe Do some quick

417
00:18:59.580 --> 00:19:02.400
comparisons. Um, you know, obviously the

418
00:19:02.410 --> 00:19:05.370
reverse. You know, the palindrome is another kind of

419
00:19:05.380 --> 00:19:08.170
string comparison, and then that these anagram wants to string

420
00:19:08.170 --> 00:19:10.930
comparison. So, you know, these things in

421
00:19:10.930 --> 00:19:13.920
high school aren't too difficult to deal with because of, you know,

422
00:19:13.930 --> 00:19:16.350
the built in functionality, the laziness, the,

423
00:19:16.740 --> 00:19:19.280
uh, just general ease of

424
00:19:19.280 --> 00:19:22.150
composition, even, you know, allows us not to have to

425
00:19:22.150 --> 00:19:24.990
have too much boilerplate and, uh, too

426
00:19:24.990 --> 00:19:27.500
much code, but yeah, so I think that's

427
00:19:27.500 --> 00:19:30.220
cool. Then they have one more that we're gonna

428
00:19:30.220 --> 00:19:33.220
quickly talk on. No, we have

429
00:19:33.230 --> 00:19:35.210
two more that we were quickly talking.

430
00:19:35.220 --> 00:19:37.260
Apologize. Um,

431
00:19:37.640 --> 00:19:40.520
we're gonna touch quickly on them. So just not

432
00:19:40.520 --> 00:19:43.320
too long. Because I would love for us to kind of get a little work, you

433
00:19:43.320 --> 00:19:46.260
know, chat about our experience and maybe some

434
00:19:46.260 --> 00:19:49.000
other things you could do to practice, um, high school

435
00:19:49.000 --> 00:19:51.990
and be able to be prepared for an interview like this. But

436
00:19:51.990 --> 00:19:54.940
there's a Min max problem. And then he

437
00:19:54.940 --> 00:19:57.610
also talks about the word frequency

438
00:19:57.610 --> 00:20:00.370
problem. So, Taylor, would you

439
00:20:00.380 --> 00:20:03.270
give us a quick synopsis of one

440
00:20:03.270 --> 00:20:04.470
or both of these?

441
00:20:04.480 --> 00:20:07.210
>> I'd be happy to. So the Min and Max problem

442
00:20:07.220 --> 00:20:09.910
is given a list of things that can be

443
00:20:09.910 --> 00:20:12.520
compared. Return me a couple with the

444
00:20:12.520 --> 00:20:15.380
greatest element in them and the least element in them, or

445
00:20:15.380 --> 00:20:18.350
the minimum and the maximum. The immediate solution that

446
00:20:18.350 --> 00:20:20.880
comes to mind is the one he goes for first year, which is

447
00:20:21.640 --> 00:20:24.270
make a double call minimum on one of them and

448
00:20:24.270 --> 00:20:27.220
maximum sorry minimum on the input list and maximum on the input

449
00:20:27.220 --> 00:20:30.220
list. And that works great, has some downsides.

450
00:20:30.230 --> 00:20:33.130
In particular, it will walk over the list

451
00:20:33.140 --> 00:20:35.670
twice, wants to look for the men and wants to look for the max.

452
00:20:35.680 --> 00:20:38.560
And if your input list is empty, it's gonna explode.

453
00:20:38.540 --> 00:20:41.540
So he spends some time fixing

454
00:20:41.540 --> 00:20:44.180
up some of those issues, which I think is great, and

455
00:20:44.640 --> 00:20:47.550
it's worth pointing out that he's able to use fold

456
00:20:47.550 --> 00:20:49.890
map here in some of the interim solutions

457
00:20:49.890 --> 00:20:52.550
because there's actually mongoloids for expressing the

458
00:20:52.550 --> 00:20:55.430
minimum or maximum element. And so, if you wrap everything

459
00:20:55.430 --> 00:20:58.350
up in those you can fold map everything together. If you want to

460
00:20:58.360 --> 00:21:01.190
learn more about monologues, go listen to our previous podcast, where

461
00:21:01.200 --> 00:21:04.170
we get drunk on mongoloids. Hmm. And then

462
00:21:04.170 --> 00:21:06.650
the other final problem is about word

463
00:21:06.650 --> 00:21:09.420
frequency, and this one, like the

464
00:21:09.420 --> 00:21:12.410
sum up Thio in Problem is a little more complicated. There's

465
00:21:12.410 --> 00:21:15.000
more moving pieces involved, but

466
00:21:15.000 --> 00:21:17.740
fortunately again, high school kind of saves us here. It's not in the

467
00:21:17.740 --> 00:21:20.630
prelude. It's not in the base library, but it isn't a boot

468
00:21:20.630 --> 00:21:23.430
library called containers. And in there there's

469
00:21:23.430 --> 00:21:26.080
a data structure for maps. And that's what he reaches for here

470
00:21:26.080 --> 00:21:28.910
to take an input list and then

471
00:21:28.910 --> 00:21:31.820
build a map where the key is a word in

472
00:21:31.820 --> 00:21:34.560
there, and the value is how often it shows up.

473
00:21:35.240 --> 00:21:37.670
And this is something that we do so

474
00:21:37.670 --> 00:21:40.610
often in, you know, interview code in riel

475
00:21:40.610 --> 00:21:43.320
code. I'm kind of surprised there's not a functioning containers

476
00:21:43.320 --> 00:21:46.240
already to do this, not specifically for strings, but just for

477
00:21:46.240 --> 00:21:49.220
anything to count up the frequencies. So maybe I'll open a p R.

478
00:21:49.220 --> 00:21:51.350
And get some credit toward Octoberfest for doing that.

479
00:21:51.840 --> 00:21:54.830
Hmm. That could be cool. Yeah, on

480
00:21:54.830 --> 00:21:57.770
Ben, really? The only other thing to point out about this

481
00:21:57.770 --> 00:22:00.750
word frequency things since we're blazing through it right now. Is

482
00:22:00.750 --> 00:22:03.400
that last week we talked about how maps When the

483
00:22:03.400 --> 00:22:06.200
union together, they're left biased.

484
00:22:06.200 --> 00:22:09.200
So it will just drop the value from the right one. And that's why

485
00:22:09.200 --> 00:22:11.770
here he has to use this union with

486
00:22:11.770 --> 00:22:14.730
function to say no. Don't just drop one of those values. In

487
00:22:14.730 --> 00:22:17.690
fact, combine them together and use addition to combine them together. So we're

488
00:22:17.690 --> 00:22:19.460
counting how often this shows up.

489
00:22:20.040 --> 00:22:22.980
>> Yeah, And I looked at this code and I was like, I feel

490
00:22:22.980 --> 00:22:25.550
like I've written this for, you know, at some

491
00:22:25.550 --> 00:22:27.990
point whether it be in our actual code

492
00:22:27.990 --> 00:22:30.180
or, you know, when I personally been

493
00:22:30.180 --> 00:22:33.030
practicing my high school knowledge, which, you

494
00:22:33.030 --> 00:22:35.910
know, um, I think, actually, the great segue into our

495
00:22:35.910 --> 00:22:38.700
next kind of topic, which is, you know, some other tools to

496
00:22:38.700 --> 00:22:41.270
practice with for us and me

497
00:22:41.270 --> 00:22:44.140
personally, I've used, you know, code wars

498
00:22:44.150 --> 00:22:46.990
and extra schism and advent of

499
00:22:46.990 --> 00:22:49.490
code to kind of, you know,

500
00:22:49.490 --> 00:22:52.270
solve various problems in high school. Uh, the

501
00:22:52.270 --> 00:22:55.090
cool thing about these platforms is that you can,

502
00:22:55.100 --> 00:22:57.940
you know, choose a language maybe you're more familiar with.

503
00:22:57.950 --> 00:23:00.560
There's a lot of languages and

504
00:23:00.540 --> 00:23:03.530
these and even avenue code. You can pick whatever language you want.

505
00:23:03.540 --> 00:23:06.260
You could do it and then expressed spreadsheet. If you could figure out the

506
00:23:06.260 --> 00:23:09.240
logic for that. And you know, I think that's

507
00:23:09.250 --> 00:23:12.220
really nice toe have because then you

508
00:23:12.220 --> 00:23:15.030
know you can reason a reason in

509
00:23:15.030 --> 00:23:17.950
a in a way you already understand. And then you

510
00:23:17.950 --> 00:23:20.830
can, you know, go to the language you're learning

511
00:23:20.840 --> 00:23:23.810
and apply it the knowledge you know there and see

512
00:23:23.810 --> 00:23:26.210
how they compare. And, you know,

513
00:23:26.220 --> 00:23:29.190
there all the questions there's wide

514
00:23:29.190 --> 00:23:32.110
range code wars is what we're using

515
00:23:32.120 --> 00:23:34.940
more recently where you know, there's, you know,

516
00:23:34.950 --> 00:23:37.440
won t eight ky you with one being the most

517
00:23:37.440 --> 00:23:40.300
difficult and eight being, you know, relatively

518
00:23:40.300 --> 00:23:43.230
simple. But it allows you to kind of get your feet

519
00:23:43.230 --> 00:23:45.960
wet and reason about problems

520
00:23:46.640 --> 00:23:49.380
kind of quickly. And then once you've kind of created a

521
00:23:49.380 --> 00:23:52.350
solution, even if it might be a man, I'll be perfect.

522
00:23:52.350 --> 00:23:55.300
You can submit it and see other people solutions,

523
00:23:55.300 --> 00:23:58.200
and you can kind of see like Okay, yeah, that makes sense.

524
00:23:58.200 --> 00:24:00.990
I see where they did this a little bit

525
00:24:00.990 --> 00:24:03.560
better on Ben. You can,

526
00:24:03.940 --> 00:24:06.870
you know, edit it, or you can comment on other people's You can

527
00:24:06.880 --> 00:24:09.260
up both. There's, you know, say, Oh, yeah, That was really

528
00:24:09.260 --> 00:24:12.240
clever. Andi. People can give you feedback on yours as well.

529
00:24:12.240 --> 00:24:15.180
So I think for us, that's been a really good

530
00:24:15.180 --> 00:24:18.060
one. Um, but I think Taylor, I would love for you to talk a

531
00:24:18.060 --> 00:24:20.930
little bit more about avenue of code because I know you've done that

532
00:24:20.930 --> 00:24:23.720
for quite a few years now, E

533
00:24:23.730 --> 00:24:26.380
get through, like, five days, and I'm like, I can't

534
00:24:26.380 --> 00:24:28.960
spend four hours on solving this problem.

535
00:24:29.340 --> 00:24:32.310
>> Advent of code is a ton of fun for those that haven't

536
00:24:32.310 --> 00:24:35.120
heard of it before. It is a yearly programming

537
00:24:35.120 --> 00:24:37.890
challenge leading up to Christmas, where you get a

538
00:24:37.890 --> 00:24:40.870
new problem every day and I forget

539
00:24:40.870 --> 00:24:43.840
when exactly they drop. It's something, uh, not very

540
00:24:43.840 --> 00:24:46.740
convenient for us here on the east coast of the U. S. It's

541
00:24:46.740 --> 00:24:49.530
like midnight UTC or something. So I'm not waking up at 4

542
00:24:49.530 --> 00:24:52.430
a.m. To go to a programming puzzle because they have

543
00:24:52.430 --> 00:24:55.400
a leader board where you can compete against everyone else in the world to see

544
00:24:55.400 --> 00:24:58.310
who does it the quickest. I'm not really in it for the

545
00:24:58.320 --> 00:25:01.290
competition side of it, but it's a good,

546
00:25:01.300 --> 00:25:04.200
interesting mix of problems that build on each

547
00:25:04.200 --> 00:25:07.140
other so often, even if it's not actually

548
00:25:07.140 --> 00:25:09.580
like you use part of the solution for the next solution. They're

549
00:25:09.580 --> 00:25:12.260
thematically related, where they use similar

550
00:25:12.270 --> 00:25:15.230
concepts for solutions. But

551
00:25:15.230 --> 00:25:17.990
there's a very big community around it. And for all of the

552
00:25:17.990 --> 00:25:20.840
problems, the solution that you submit is

553
00:25:20.850 --> 00:25:23.600
some simple text value, so you can solve it with

554
00:25:23.610 --> 00:25:26.550
anything that you want. Like you mentioned Cam. You could do an Excel

555
00:25:26.550 --> 00:25:29.420
spreadsheet or with pencil and paper. And this is

556
00:25:29.420 --> 00:25:32.180
really nice because it gives you the flexibility to say, Well,

557
00:25:32.190 --> 00:25:35.140
maybe I don't know how to solve this in Haskell yet, but I

558
00:25:35.140 --> 00:25:38.040
do know how I would solve it in Java or Python or

559
00:25:38.040 --> 00:25:41.040
whatever language I used before. So I'm going to do it there and

560
00:25:41.040 --> 00:25:43.770
then show that I can come up with the right

561
00:25:43.770 --> 00:25:46.510
solution and then figure out how to convert it over or

562
00:25:46.520 --> 00:25:49.180
just go look at other people's solutions and

563
00:25:49.190 --> 00:25:52.130
try to understand them and see what they're doing. Because maybe I wouldn't have been

564
00:25:52.130 --> 00:25:54.910
able to get there myself. Um, but yeah.

565
00:25:54.910 --> 00:25:56.690
Advent of code, super fun.

566
00:25:56.700 --> 00:25:59.540
>> You know, I was gonna say, I think I'm gonna start submitting

567
00:25:59.540 --> 00:26:02.460
some, uh, Excel spreadsheets as PR's into our code

568
00:26:02.460 --> 00:26:05.450
base. So e mean, it solves the problem,

569
00:26:05.450 --> 00:26:05.920
right?

570
00:26:05.930 --> 00:26:08.810
>> It does. You can submit those, but be ready for

571
00:26:08.810 --> 00:26:09.690
them to be rejected.

572
00:26:09.700 --> 00:26:12.490
>> Okay, that's understandable, but

573
00:26:12.490 --> 00:26:15.240
yeah, I think I think those air other tools that we can

574
00:26:15.240 --> 00:26:18.090
use to prepare for, you know, thinking

575
00:26:18.090 --> 00:26:21.080
quick on our feet because that's kind of what the interview process is all

576
00:26:21.080 --> 00:26:23.910
about is alright. I'm throwing a issue. How

577
00:26:23.910 --> 00:26:26.690
doe I create some resemblance off a

578
00:26:26.690 --> 00:26:29.260
solution in a five minute window.

579
00:26:29.640 --> 00:26:32.160
And the more you expose yourself to

580
00:26:32.160 --> 00:26:34.750
difficult problems and have to reason about difficult

581
00:26:34.750 --> 00:26:37.410
things, the quicker you are to find that

582
00:26:37.410 --> 00:26:39.900
solution or find a solution that at least solves a

583
00:26:39.900 --> 00:26:42.900
problem. Um, I think this week we were

584
00:26:42.900 --> 00:26:45.860
talking to one of our other engineer friends, Cody, and

585
00:26:45.860 --> 00:26:48.590
he was kind of talking and brought up. This proposition of, like,

586
00:26:48.600 --> 00:26:51.540
better is better or worse, is better in the programming

587
00:26:51.540 --> 00:26:54.320
world. And, you know, we could spend a lot of time and

588
00:26:54.330 --> 00:26:57.250
architect the perfect solution and, you know, be better

589
00:26:57.250 --> 00:27:00.030
is better. But if we're not able to

590
00:27:00.040 --> 00:27:03.020
get a solution out there and and get something in front

591
00:27:03.020 --> 00:27:05.960
of a customer or in front of whoever the

592
00:27:05.960 --> 00:27:08.850
stakeholder is like, what are we doing? So kind

593
00:27:08.850 --> 00:27:11.530
of worse is sometimes better because it's there,

594
00:27:11.540 --> 00:27:14.130
it's usable. They know how to deal with it

595
00:27:14.140 --> 00:27:16.970
on DSo. Like getting that practice

596
00:27:16.970 --> 00:27:19.970
with these, you know, coding challenges and things

597
00:27:20.120 --> 00:27:22.580
is gonna help you for different

598
00:27:22.590 --> 00:27:25.420
interviews as you progress in your career

599
00:27:25.430 --> 00:27:27.620
on move from place to place.

600
00:27:27.630 --> 00:27:30.630
Uh, but yeah, you know. And the funny thing

601
00:27:30.630 --> 00:27:33.070
is, like, Taylor, you and I have very different

602
00:27:33.440 --> 00:27:35.790
work experience. Mine

603
00:27:35.800 --> 00:27:38.330
is an intern turned

604
00:27:38.340 --> 00:27:40.590
engineer still working for the same place

605
00:27:40.600 --> 00:27:43.520
for, you know, almost going on five

606
00:27:43.520 --> 00:27:46.180
years now. So that's my experience.

607
00:27:46.180 --> 00:27:49.100
I have done some of these interview questions

608
00:27:49.100 --> 00:27:52.010
and stuff before, but it was right out of

609
00:27:52.010 --> 00:27:54.750
college, which for me, that was really hard to

610
00:27:54.750 --> 00:27:57.720
reason about. Like I had data structures. I had, you

611
00:27:57.720 --> 00:28:00.490
know, all these courses. But I hadn't had any

612
00:28:00.490 --> 00:28:03.460
practice. So for me, it was really difficult to like

613
00:28:03.470 --> 00:28:05.670
put those words into actions. Um,

614
00:28:06.440 --> 00:28:09.060
but luckily, you know, had

615
00:28:09.060 --> 00:28:11.840
opportunities here at pro Aunt had actually a

616
00:28:11.840 --> 00:28:14.440
couple of other opportunities. And they really

617
00:28:14.440 --> 00:28:17.390
value just the ability to verbalize

618
00:28:17.400 --> 00:28:20.300
what you're trying to dio. And so I

619
00:28:20.300 --> 00:28:22.710
would maybe even suggest that you do various

620
00:28:22.710 --> 00:28:25.010
challenges, maybe verbalize and

621
00:28:25.010 --> 00:28:27.990
say I'm doing this solution because

622
00:28:28.000 --> 00:28:30.870
even if it's just you in your room, I still

623
00:28:30.870 --> 00:28:33.850
think that's valuable for you. Moving forward. Yeah,

624
00:28:33.850 --> 00:28:36.790
>> I think that's a good way to get comfortable in

625
00:28:36.790 --> 00:28:39.780
that type of scenario, because clearly an interview coding

626
00:28:39.780 --> 00:28:42.760
challenge isn't exactly the same as your day job. Normally, you're

627
00:28:42.760 --> 00:28:45.260
not in front of a white board or explaining your problem

628
00:28:45.260 --> 00:28:47.800
solution as you're working through it. But

629
00:28:47.800 --> 00:28:50.650
one interesting way to work

630
00:28:50.650 --> 00:28:53.290
on these that I think has become more realistic

631
00:28:53.290 --> 00:28:56.110
recently is to stream your solution or

632
00:28:56.120 --> 00:28:59.120
maybe not stream it, but pretend like you are where Okay, if

633
00:28:59.120 --> 00:29:02.120
I was sitting here and I had my window open and there was a camera on me and I

634
00:29:02.120 --> 00:29:04.710
was streaming on YouTube, how would I

635
00:29:04.710 --> 00:29:07.700
explain to the people watching what it is that I'm doing and why

636
00:29:07.700 --> 00:29:10.600
I'm doing it? Because as someone who has conducted a

637
00:29:10.600 --> 00:29:13.220
fair amount of technical interviews.

638
00:29:13.230 --> 00:29:15.870
That's ultimately what I'm more interested in rather

639
00:29:15.870 --> 00:29:18.730
than can they solve this problem? So if I ask

640
00:29:18.730 --> 00:29:21.710
someone, can you solve the fizz buzz problem? And they say, yes, they

641
00:29:21.710 --> 00:29:24.610
quickly write it on the on the board. That's good. But I would

642
00:29:24.610 --> 00:29:27.470
prefer to hear you know, how they're working through how they're

643
00:29:27.470 --> 00:29:29.400
thinking how they like to approach problems.

644
00:29:29.410 --> 00:29:32.320
>> Yeah, I think the two point back to

645
00:29:32.320 --> 00:29:35.160
the article, I think he does a good job explaining of why he

646
00:29:35.160 --> 00:29:38.050
did what he did and some kind of as you read

647
00:29:38.050 --> 00:29:41.000
through the block post, you have the ability to kind

648
00:29:41.000 --> 00:29:43.930
of see how he reasoned about the problem. Um,

649
00:29:43.940 --> 00:29:46.750
you know, and obviously you hear how how we would reason and

650
00:29:46.750 --> 00:29:49.400
verbalize it, you know, through the podcast.

651
00:29:49.410 --> 00:29:52.180
But yeah, overall, I think this is a great block block

652
00:29:52.180 --> 00:29:55.100
post, and I really think we had a great time today on this On

653
00:29:55.100 --> 00:29:56.800
the on the podcast.

654
00:29:56.810 --> 00:29:59.610
>> Yeah, I sure did. I hope you all had a good

655
00:29:59.610 --> 00:30:02.170
time listening on. I think that will do it for us

656
00:30:02.170 --> 00:30:04.630
today. This has been the high School Weekly

657
00:30:04.630 --> 00:30:07.560
podcast. I'm your host, Taylor Foss AC. And with me

658
00:30:07.560 --> 00:30:10.380
today was Cameron Gara. If you'd like to learn

659
00:30:10.380 --> 00:30:13.380
more about the podcast or our newsletter, please

660
00:30:13.380 --> 00:30:16.170
visit our website Haskell weekly dot News

661
00:30:16.440 --> 00:30:19.060
Or you can catch us on social Media. Our Twitter

662
00:30:19.060 --> 00:30:21.990
handle is Haskell Weekly. Were on Reddit as High School Weekly

663
00:30:21.990 --> 00:30:24.900
were on Git Hub is high school weekly pretty much everywhere we're

664
00:30:24.900 --> 00:30:27.800
asking weekly. Also, if you could take a

665
00:30:27.800 --> 00:30:30.290
minute to go rate and review us on apple

666
00:30:30.290 --> 00:30:33.020
podcasts. We currently have a five star rating

667
00:30:33.030 --> 00:30:35.960
with 16 ratings. So that's 80 stars that people have given us.

668
00:30:35.970 --> 00:30:38.910
And if you want to give us some more, that's great. If you think we suck, let

669
00:30:38.910 --> 00:30:40.640
us know and we'll try to get better. You

670
00:30:40.640 --> 00:30:43.480
>> know, Haskell Weekly podcast is brought to you by I t. Pro

671
00:30:43.480 --> 00:30:46.390
TV, an e learning platform for I

672
00:30:46.390 --> 00:30:49.140
t professionals and also our employer.

673
00:30:49.150 --> 00:30:51.700
But, you know, we would love toe

674
00:30:51.710 --> 00:30:54.280
extend an offer if you're interested in an I t

675
00:30:54.280 --> 00:30:56.980
content, um, to you with a

676
00:30:56.990 --> 00:30:59.520
promo code of high school weekly

677
00:30:59.530 --> 00:31:02.080
30. That is high school

678
00:31:02.090 --> 00:31:04.640
weekly 30 All one word.

679
00:31:04.650 --> 00:31:07.330
Um and if you want to check it

680
00:31:07.330 --> 00:31:09.550
out. You know? Obviously have a free membership. Us. Well,

681
00:31:09.550 --> 00:31:12.480
so come over. I t pro TV. You

682
00:31:12.480 --> 00:31:15.440
know, it's I t pro dot tv. Easy to find.

683
00:31:15.450 --> 00:31:18.240
Easy to see. Um, come check out our great content

684
00:31:18.250 --> 00:31:21.170
and keep hanging out. We really love doing this. And

685
00:31:21.170 --> 00:31:23.720
we really are thankful that I t pro lets us do this.

686
00:31:23.720 --> 00:31:26.040
So it's been a good day, man.

687
00:31:26.050 --> 00:31:28.550
>> Sure has. I'll see you all next week

688
00:31:28.780 --> 00:31:29.870
piece by.
