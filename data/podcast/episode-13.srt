1
00:00:00,000 --> 00:00:03,050
Oh

2
00:00:01,430 --> 00:00:05,729
[Music]

3
00:00:03,050 --> 00:00:06,510
hello and welcome to the Haskell weekly

4
00:00:05,729 --> 00:00:09,150
podcast

5
00:00:06,510 --> 00:00:12,240
I'm your host Taylor fossick I'm the

6
00:00:09,150 --> 00:00:14,429
lead engineer at IT Pro TV with me today

7
00:00:12,240 --> 00:00:16,110
is Cameron Guerra one of the engineers

8
00:00:14,429 --> 00:00:18,000
on my team thanks for joining me today

9
00:00:16,110 --> 00:00:20,190
cam thanks for having me Taylor it's

10
00:00:18,000 --> 00:00:22,500
good to have you on the show and on this

11
00:00:20,190 --> 00:00:24,210
show we talk about Haskell no surprise

12
00:00:22,500 --> 00:00:25,830
there it's a purely functional

13
00:00:24,210 --> 00:00:27,420
programming language but what

14
00:00:25,830 --> 00:00:28,830
specifically are we gonna be talking

15
00:00:27,420 --> 00:00:31,260
about today cam gonna be talking about

16
00:00:28,830 --> 00:00:31,560
why Haskell why Haskell what do you mean

17
00:00:31,260 --> 00:00:35,010
by that

18
00:00:31,560 --> 00:00:37,589
well there was a blog post by the

19
00:00:35,010 --> 00:00:39,149
Symantec team at github called why high

20
00:00:37,589 --> 00:00:41,940
school and why they chose Haskell for

21
00:00:39,149 --> 00:00:45,239
that project kind of led by Timothy Klem

22
00:00:41,940 --> 00:00:46,230
so okay so github is using Haskell in

23
00:00:45,239 --> 00:00:48,480
production that's awesome

24
00:00:46,230 --> 00:00:50,249
yeah the big secret we're not the only

25
00:00:48,480 --> 00:00:53,010
company out there with with Haskell code

26
00:00:50,249 --> 00:00:55,460
in problem there's some big time but

27
00:00:53,010 --> 00:00:57,809
before we kind of get into their article

28
00:00:55,460 --> 00:01:01,319
what are we gonna start with what is

29
00:00:57,809 --> 00:01:04,710
Symantec and why maybe this has a little

30
00:01:01,319 --> 00:01:07,619
good for them yeah so Symantec is a I

31
00:01:04,710 --> 00:01:09,659
guess package or program by the github

32
00:01:07,619 --> 00:01:13,619
team and it's what they use to analyze

33
00:01:09,659 --> 00:01:16,049
and compare source code on their servers

34
00:01:13,619 --> 00:01:18,329
so like when you submit a pull request

35
00:01:16,049 --> 00:01:19,860
to github you may notice that in

36
00:01:18,329 --> 00:01:22,409
addition to like being able to break it

37
00:01:19,860 --> 00:01:24,360
down by file you know jump to this file

38
00:01:22,409 --> 00:01:26,939
in the diff you can also jump to

39
00:01:24,360 --> 00:01:28,829
specific functions and say show me the

40
00:01:26,939 --> 00:01:30,659
changes on this function alone and

41
00:01:28,829 --> 00:01:32,700
Symantec is a tool on their back-end

42
00:01:30,659 --> 00:01:34,409
that allows that to happen so they can

43
00:01:32,700 --> 00:01:35,939
parse the source code of JavaScript or

44
00:01:34,409 --> 00:01:37,469
Python or whatever and figure out oh

45
00:01:35,939 --> 00:01:40,770
this is a function and something within

46
00:01:37,469 --> 00:01:44,909
that function changed no that's awesome

47
00:01:40,770 --> 00:01:48,119
why was this announcement big news this

48
00:01:44,909 --> 00:01:50,429
is a big deal because github obviously

49
00:01:48,119 --> 00:01:52,320
is a giant force in the development

50
00:01:50,429 --> 00:01:54,439
community mm-hmm a lot of people use

51
00:01:52,320 --> 00:01:56,549
github to manage their source code and

52
00:01:54,439 --> 00:01:58,399
they're just a huge company so they've

53
00:01:56,549 --> 00:02:00,840
got lots of people working for them and

54
00:01:58,399 --> 00:02:03,119
this is a big deal because haskell is a

55
00:02:00,840 --> 00:02:05,009
pretty small community especially in

56
00:02:03,119 --> 00:02:06,299
relation to all of github you know right

57
00:02:05,009 --> 00:02:08,940
there aren't too many companies out

58
00:02:06,299 --> 00:02:10,739
there using haskell a couple of the big

59
00:02:08,940 --> 00:02:13,200
ones that I can think of off the top my

60
00:02:10,739 --> 00:02:15,420
head are facebook and Nike mm-hm and us

61
00:02:13,200 --> 00:02:16,620
of course but you know ITT

62
00:02:15,420 --> 00:02:20,130
yeah we're coming we're coming for your

63
00:02:16,620 --> 00:02:23,370
Facebook ID Pro TV the next Facebook the

64
00:02:20,130 --> 00:02:25,050
IT world but yeah this is this is just a

65
00:02:23,370 --> 00:02:26,970
big deal cuz github is a big company and

66
00:02:25,050 --> 00:02:28,410
Haskell's a small language and it is

67
00:02:26,970 --> 00:02:30,660
really interesting to a lot of people

68
00:02:28,410 --> 00:02:32,550
yeah it's good to see the community

69
00:02:30,660 --> 00:02:33,989
growing you know and yeah bigger

70
00:02:32,550 --> 00:02:38,489
organizations picking up this language

71
00:02:33,989 --> 00:02:41,459
allows for the community to to obviously

72
00:02:38,489 --> 00:02:43,230
grow I mean there's so many employees at

73
00:02:41,459 --> 00:02:44,519
github and you know obviously just the

74
00:02:43,230 --> 00:02:45,750
semantics team right now it's using high

75
00:02:44,519 --> 00:02:47,840
school but I'm sure it's spreading

76
00:02:45,750 --> 00:02:50,370
through their organization and kind of

77
00:02:47,840 --> 00:02:53,130
its gonna allow our community to

78
00:02:50,370 --> 00:02:54,630
continue to grow and have you know more

79
00:02:53,130 --> 00:02:56,640
experts in the field you know absolutely

80
00:02:54,630 --> 00:02:58,350
it's really cool even if you're at a

81
00:02:56,640 --> 00:03:00,299
smaller company and you're interested in

82
00:02:58,350 --> 00:03:01,830
using haskell this can be really useful

83
00:03:00,299 --> 00:03:03,540
because you can point to github and say

84
00:03:01,830 --> 00:03:04,980
look they're using it and it's working

85
00:03:03,540 --> 00:03:09,450
for them it can work for us too right

86
00:03:04,980 --> 00:03:11,519
and a lot of the articles out there

87
00:03:09,450 --> 00:03:13,980
about why people choose haskell are are

88
00:03:11,519 --> 00:03:17,760
pretty normal like they're pretty

89
00:03:13,980 --> 00:03:21,090
standard like this this and this but why

90
00:03:17,760 --> 00:03:24,540
do you think you know github kind of

91
00:03:21,090 --> 00:03:26,430
chose this different path there's

92
00:03:24,540 --> 00:03:29,579
different paths to using haskell right

93
00:03:26,430 --> 00:03:30,870
yeah so for a lot of the blog posts that

94
00:03:29,579 --> 00:03:33,180
I've read in the past about why

95
00:03:30,870 --> 00:03:35,940
companies have chose haskell it you sort

96
00:03:33,180 --> 00:03:37,769
of see the same reasons trotted out you

97
00:03:35,940 --> 00:03:39,000
know haskell is a pure language so you

98
00:03:37,769 --> 00:03:41,609
don't have to worry about side effects

99
00:03:39,000 --> 00:03:42,870
and weird parts of your code or as lazy

100
00:03:41,609 --> 00:03:44,790
evaluation so you don't have to worry

101
00:03:42,870 --> 00:03:48,269
about things being evaluated even if you

102
00:03:44,790 --> 00:03:50,970
don't end up using them or it you know

103
00:03:48,269 --> 00:03:53,730
lets you express complicated ideas in a

104
00:03:50,970 --> 00:03:55,079
small amount of code and the first time

105
00:03:53,730 --> 00:03:56,940
you see that set of arguments it might

106
00:03:55,079 --> 00:03:58,260
be compelling but the fifth or tenth or

107
00:03:56,940 --> 00:03:59,010
under the time you see them you're like

108
00:03:58,260 --> 00:04:00,299
okay i get it

109
00:03:59,010 --> 00:04:02,730
I know Haskell has those things what

110
00:04:00,299 --> 00:04:04,790
else can I do mm-hmm that's awesome yeah

111
00:04:02,730 --> 00:04:08,519
and I think it's really cool that they

112
00:04:04,790 --> 00:04:09,600
kind of broke it down they had some

113
00:04:08,519 --> 00:04:11,970
different reasons for choosing high

114
00:04:09,600 --> 00:04:14,190
schools so do you kind of want to kick

115
00:04:11,970 --> 00:04:17,400
off you know what reasons they chosen

116
00:04:14,190 --> 00:04:18,539
and why they chose high school sure as I

117
00:04:17,400 --> 00:04:19,889
mentioned there's kind of the bog

118
00:04:18,539 --> 00:04:22,350
standard reasons for why people

119
00:04:19,889 --> 00:04:23,669
typically choose Haskell but one thing

120
00:04:22,350 --> 00:04:25,320
that I like about this article is they

121
00:04:23,669 --> 00:04:27,479
didn't dwell on that too much they said

122
00:04:25,320 --> 00:04:28,710
yeah these are all characteristics of

123
00:04:27,479 --> 00:04:29,159
Haskell these are reasons why you might

124
00:04:28,710 --> 00:04:32,849
want to choose

125
00:04:29,159 --> 00:04:35,249
but they ended up focusing more on what

126
00:04:32,849 --> 00:04:37,229
come or things that are only possible

127
00:04:35,249 --> 00:04:39,599
because of those kind of fundamental

128
00:04:37,229 --> 00:04:41,550
characteristics but more compelling

129
00:04:39,599 --> 00:04:43,379
reasons for their particular business

130
00:04:41,550 --> 00:04:45,569
case and I think the one that they start

131
00:04:43,379 --> 00:04:48,689
with is control flow right correct yep

132
00:04:45,569 --> 00:04:51,719
and so by control flow what they mean is

133
00:04:48,689 --> 00:04:55,919
that in a typical programming language

134
00:04:51,719 --> 00:04:58,110
something like Java or C sharp or go the

135
00:04:55,919 --> 00:05:00,779
control flow is built into the language

136
00:04:58,110 --> 00:05:02,309
itself so like if a statement is above

137
00:05:00,779 --> 00:05:04,589
another one you know that it's going to

138
00:05:02,309 --> 00:05:07,019
get executed first so you need top to

139
00:05:04,589 --> 00:05:08,879
bottom left to right basically and in

140
00:05:07,019 --> 00:05:11,639
Haskell that's not necessarily the case

141
00:05:08,879 --> 00:05:13,800
you can write code that looks the same

142
00:05:11,639 --> 00:05:16,019
but one version of it might be

143
00:05:13,800 --> 00:05:19,019
synchronous and another version of it

144
00:05:16,019 --> 00:05:20,279
might be asynchronous so you know this

145
00:05:19,019 --> 00:05:22,679
comes up in JavaScript all the time

146
00:05:20,279 --> 00:05:24,119
where the synchronous function is really

147
00:05:22,679 --> 00:05:25,529
easy to write but you block the main

148
00:05:24,119 --> 00:05:28,139
thread for a long time and if you're

149
00:05:25,529 --> 00:05:28,649
doing something with a web UI then your

150
00:05:28,139 --> 00:05:30,329
UI

151
00:05:28,649 --> 00:05:32,249
stalls wow that synchronous thing is

152
00:05:30,329 --> 00:05:34,289
happening so you want to write stuff in

153
00:05:32,249 --> 00:05:35,969
this async fashion but then you have to

154
00:05:34,289 --> 00:05:37,740
do like nested callback so you do the

155
00:05:35,969 --> 00:05:39,959
async await or something like that right

156
00:05:37,740 --> 00:05:41,819
so the syntax you have to change the way

157
00:05:39,959 --> 00:05:43,769
that you write your code in order to

158
00:05:41,819 --> 00:05:46,769
change how the control flow works mm-hmm

159
00:05:43,769 --> 00:05:48,779
but with Haskell you the code that you

160
00:05:46,769 --> 00:05:51,449
write looks the same but you can change

161
00:05:48,779 --> 00:05:54,240
how it's implemented or not implemented

162
00:05:51,449 --> 00:05:57,779
but executed right right so pretty much

163
00:05:54,240 --> 00:05:59,759
higher up in in the program is where

164
00:05:57,779 --> 00:06:01,709
kind of the deciding factor of oh is a

165
00:05:59,759 --> 00:06:04,409
sinker this asynchronous or synchronous

166
00:06:01,709 --> 00:06:06,149
like exactly and the further you get

167
00:06:04,409 --> 00:06:09,269
into the code it just looks the same and

168
00:06:06,149 --> 00:06:10,709
it's not you don't have to like be

169
00:06:09,269 --> 00:06:13,289
worried of Oh am i writing this the

170
00:06:10,709 --> 00:06:15,779
right way mm-hmm because in the end I

171
00:06:13,289 --> 00:06:18,329
want this result like the code you write

172
00:06:15,779 --> 00:06:20,519
is can be executed however you want it

173
00:06:18,329 --> 00:06:21,869
to be executed you just tell that you

174
00:06:20,519 --> 00:06:24,029
know once you start to write the

175
00:06:21,869 --> 00:06:26,699
executable and make that code come true

176
00:06:24,029 --> 00:06:28,949
yeah and that's especially useful for

177
00:06:26,699 --> 00:06:31,439
the semantics team because what they're

178
00:06:28,949 --> 00:06:34,050
doing is parsing and analyzing source

179
00:06:31,439 --> 00:06:37,019
code so they want to be able to parse

180
00:06:34,050 --> 00:06:39,569
let's say a Python file and analyze it

181
00:06:37,019 --> 00:06:41,129
as if it was executing but not actually

182
00:06:39,569 --> 00:06:42,720
execute it mm-hmm and so it becomes

183
00:06:41,129 --> 00:06:45,120
really powerful to have you know the

184
00:06:42,720 --> 00:06:46,410
to lascal provides to be able to manage

185
00:06:45,120 --> 00:06:48,300
the control flow in the same way that

186
00:06:46,410 --> 00:06:53,940
you manage regular data in other

187
00:06:48,300 --> 00:06:55,230
languages right so the other thing they

188
00:06:53,940 --> 00:06:59,670
kind of talked about and the reason they

189
00:06:55,230 --> 00:07:01,560
chose it was runtime correctness and you

190
00:06:59,670 --> 00:07:03,150
know they gave a lot of really great you

191
00:07:01,560 --> 00:07:04,680
know things we've kind of experienced

192
00:07:03,150 --> 00:07:06,900
but what were some of the things you

193
00:07:04,680 --> 00:07:08,910
took away from you know that that aspect

194
00:07:06,900 --> 00:07:10,740
of the article I really liked that

195
00:07:08,910 --> 00:07:12,360
aspect of the article and I'm glad that

196
00:07:10,740 --> 00:07:14,880
they brought it up because when you read

197
00:07:12,360 --> 00:07:17,640
about let's say Elm another language

198
00:07:14,880 --> 00:07:19,140
that's in the same vein they bring that

199
00:07:17,640 --> 00:07:21,510
front and center all the time it's like

200
00:07:19,140 --> 00:07:22,860
on their homepage you know they say you

201
00:07:21,510 --> 00:07:24,060
can write programs with confidence and

202
00:07:22,860 --> 00:07:26,520
not have to worry about runtime errors

203
00:07:24,060 --> 00:07:28,560
and I wish Haskell marketed more in that

204
00:07:26,520 --> 00:07:30,390
direction because it is really powerful

205
00:07:28,560 --> 00:07:33,210
to not have to worry about those runtime

206
00:07:30,390 --> 00:07:36,390
errors and trust that when you write the

207
00:07:33,210 --> 00:07:39,150
program and it compiles it will almost

208
00:07:36,390 --> 00:07:40,620
want or what you intended for it to do

209
00:07:39,150 --> 00:07:43,050
right and you don't have to worry oh

210
00:07:40,620 --> 00:07:44,190
crap well I forgot that this value could

211
00:07:43,050 --> 00:07:45,960
be null so then you get a

212
00:07:44,190 --> 00:07:48,300
nullpointerexception in production or

213
00:07:45,960 --> 00:07:50,040
you forgot I changed the name of that

214
00:07:48,300 --> 00:07:51,390
method last week and I forgot to update

215
00:07:50,040 --> 00:07:53,370
it here at this call site so now I'm

216
00:07:51,390 --> 00:07:55,470
getting a method not found error right

217
00:07:53,370 --> 00:07:58,110
it saves you from those really tedious

218
00:07:55,470 --> 00:08:00,030
kind of rote problems and so that you

219
00:07:58,110 --> 00:08:01,380
can focus on developing new features and

220
00:08:00,030 --> 00:08:04,320
shipping those out to your users rather

221
00:08:01,380 --> 00:08:05,640
than fixing some bug that popped up in

222
00:08:04,320 --> 00:08:08,280
your issue tracker for the hundredth

223
00:08:05,640 --> 00:08:11,160
time yeah one thing I wish Haskell was

224
00:08:08,280 --> 00:08:13,050
magical and it can be we just aren't

225
00:08:11,160 --> 00:08:17,580
necessarily using it right now at ITP

226
00:08:13,050 --> 00:08:22,530
OTV is the kind of a way to get away

227
00:08:17,580 --> 00:08:26,280
from accidentally like miss aligning

228
00:08:22,530 --> 00:08:28,680
like a value for a JSON or something

229
00:08:26,280 --> 00:08:31,860
like that because we've kind of you know

230
00:08:28,680 --> 00:08:34,080
some of our parsing for our JSON parsing

231
00:08:31,860 --> 00:08:37,409
we use the applicative stuff and that

232
00:08:34,080 --> 00:08:39,210
kind of enters that like hey this could

233
00:08:37,409 --> 00:08:42,599
end up being different because you miss

234
00:08:39,210 --> 00:08:46,230
a line you know the keys or whatever so

235
00:08:42,599 --> 00:08:48,270
I I think as a group of developers I

236
00:08:46,230 --> 00:08:51,390
would like for us to kind of lead lean

237
00:08:48,270 --> 00:08:53,550
more into okay let's not you duplicative

238
00:08:51,390 --> 00:08:55,890
just so we can make sure we keep our

239
00:08:53,550 --> 00:08:56,580
sanity because I mean a few months ago I

240
00:08:55,890 --> 00:08:57,959
was

241
00:08:56,580 --> 00:08:59,730
just banging my head against the wall

242
00:08:57,959 --> 00:09:02,820
trying to figure out like wait a second

243
00:08:59,730 --> 00:09:04,950
what's happening here and sure enough it

244
00:09:02,820 --> 00:09:08,250
was just a Miss a flip flopped key

245
00:09:04,950 --> 00:09:10,950
mm-hmm that brings up a good point that

246
00:09:08,250 --> 00:09:13,380
just because Haskell gets rid of a large

247
00:09:10,950 --> 00:09:14,970
portion of runtime errors doesn't mean

248
00:09:13,380 --> 00:09:17,850
that it gets rid of all of them and in

249
00:09:14,970 --> 00:09:19,140
fact it's not even desirable to get rid

250
00:09:17,850 --> 00:09:21,600
of all of them because you'd have to pay

251
00:09:19,140 --> 00:09:22,769
so much upfront in order to do that but

252
00:09:21,600 --> 00:09:25,470
there are some things like you mentioned

253
00:09:22,769 --> 00:09:27,630
with the applicative syntax where they

254
00:09:25,470 --> 00:09:30,120
allow you to sort of accidentally

255
00:09:27,630 --> 00:09:32,640
introduce problems that are very hard to

256
00:09:30,120 --> 00:09:35,130
detect and there are easy ways around

257
00:09:32,640 --> 00:09:37,649
that in our case doing those

258
00:09:35,130 --> 00:09:39,269
excuse me writing those parsers in a

259
00:09:37,649 --> 00:09:40,950
more monadic style makes it clearer

260
00:09:39,269 --> 00:09:42,660
which things are going where so you can

261
00:09:40,950 --> 00:09:45,120
look at a line and say oh no we're

262
00:09:42,660 --> 00:09:47,010
pulling this field that's named price

263
00:09:45,120 --> 00:09:48,570
but we're pulling it from a you know

264
00:09:47,010 --> 00:09:50,430
object where the key we're looking for

265
00:09:48,570 --> 00:09:54,480
is named and that obviously doesn't line

266
00:09:50,430 --> 00:09:56,190
up right yeah so I mean I do I do think

267
00:09:54,480 --> 00:09:58,200
a lot of the things that Haskell

268
00:09:56,190 --> 00:10:00,570
provides for runtime correct misses are

269
00:09:58,200 --> 00:10:02,910
great so I'm really glad that they kind

270
00:10:00,570 --> 00:10:05,010
of echoed that because like you said Elm

271
00:10:02,910 --> 00:10:07,290
that's something they boast all about

272
00:10:05,010 --> 00:10:08,970
yeah but Haskell you don't really hear

273
00:10:07,290 --> 00:10:11,310
about that until you're in and you're

274
00:10:08,970 --> 00:10:13,320
like oh this isn't gonna let me like

275
00:10:11,310 --> 00:10:15,390
change a function name over here without

276
00:10:13,320 --> 00:10:15,930
updating all the callers like that's not

277
00:10:15,390 --> 00:10:17,820
possible

278
00:10:15,930 --> 00:10:20,760
yep um because that compiler will not

279
00:10:17,820 --> 00:10:21,600
will not be happy with you that's

280
00:10:20,760 --> 00:10:24,390
awesome

281
00:10:21,600 --> 00:10:26,579
the other they make I'm a touchstone was

282
00:10:24,390 --> 00:10:30,020
kind of the research so academia is kind

283
00:10:26,579 --> 00:10:32,790
of leaning more towards high school as a

284
00:10:30,020 --> 00:10:34,589
language that you know these new

285
00:10:32,790 --> 00:10:36,930
research methods are kind of written in

286
00:10:34,589 --> 00:10:41,000
these algorithms and all this various

287
00:10:36,930 --> 00:10:45,060
stuff you know what is what is that

288
00:10:41,000 --> 00:10:48,449
useful for for github you touched on it

289
00:10:45,060 --> 00:10:49,949
a little already in that a lot of

290
00:10:48,449 --> 00:10:52,440
computer science papers are written

291
00:10:49,949 --> 00:10:55,350
using Haskell or a language that's very

292
00:10:52,440 --> 00:10:57,089
close to Haskell but you know that kind

293
00:10:55,350 --> 00:10:58,680
of typical computer science paper that

294
00:10:57,089 --> 00:11:00,240
you read with the the font that

295
00:10:58,680 --> 00:11:02,190
everybody knows and the like you column

296
00:11:00,240 --> 00:11:03,570
layout and the all that stuff the code

297
00:11:02,190 --> 00:11:07,320
that you look at in those papers is a

298
00:11:03,570 --> 00:11:10,380
usually Haskell and if you can take that

299
00:11:07,320 --> 00:11:13,070
code from an established research paper

300
00:11:10,380 --> 00:11:16,080
and more or less copy pasted into your

301
00:11:13,070 --> 00:11:18,480
library and start using it right away

302
00:11:16,080 --> 00:11:20,970
that's a huge win versus if you were

303
00:11:18,480 --> 00:11:23,190
using basically any other language you

304
00:11:20,970 --> 00:11:25,020
would have to think okay how can I port

305
00:11:23,190 --> 00:11:26,970
this behavior that I want that they're

306
00:11:25,020 --> 00:11:28,770
talking about in this paper into the

307
00:11:26,970 --> 00:11:30,810
language that I have and you have to

308
00:11:28,770 --> 00:11:32,430
change the semantics you have to change

309
00:11:30,810 --> 00:11:33,570
the you know actual shape of the code

310
00:11:32,430 --> 00:11:36,000
itself you have to make sure everything

311
00:11:33,570 --> 00:11:38,310
works the way you expected so it's just

312
00:11:36,000 --> 00:11:41,430
it's just more difficult to do that now

313
00:11:38,310 --> 00:11:43,050
that's not a common problem for you know

314
00:11:41,430 --> 00:11:45,300
workaday programmers like us you know

315
00:11:43,050 --> 00:11:47,100
we're writing web apps we're not looking

316
00:11:45,300 --> 00:11:49,020
into research papers to figure out well

317
00:11:47,100 --> 00:11:51,240
how do we parse JSON it's it's kind of a

318
00:11:49,020 --> 00:11:54,120
solved problem at this point right which

319
00:11:51,240 --> 00:11:55,950
is nice but it is also helpful if you're

320
00:11:54,120 --> 00:11:57,990
you know trying to be on the cutting

321
00:11:55,950 --> 00:12:01,080
edge of technology and the growth in

322
00:11:57,990 --> 00:12:05,190
technology mm-hmm research papers have

323
00:12:01,080 --> 00:12:06,360
high school that's where those papers

324
00:12:05,190 --> 00:12:08,400
are still coming out programming

325
00:12:06,360 --> 00:12:12,300
language theory not a solved field and

326
00:12:08,400 --> 00:12:13,560
the semantics team at github is on the

327
00:12:12,300 --> 00:12:16,440
cutting edge of this you know they are

328
00:12:13,560 --> 00:12:18,120
analyzing source code for millions of

329
00:12:16,440 --> 00:12:19,830
software projects across many different

330
00:12:18,120 --> 00:12:22,980
programming languages and they want to

331
00:12:19,830 --> 00:12:24,420
do it quickly effectively safely and the

332
00:12:22,980 --> 00:12:25,710
research is kind of showing them how to

333
00:12:24,420 --> 00:12:27,660
do that and they're able to crib from it

334
00:12:25,710 --> 00:12:29,670
effectively no and I think that's really

335
00:12:27,660 --> 00:12:33,720
awesome so I definitely applaud them for

336
00:12:29,670 --> 00:12:35,700
oh yeah me too this article also kind of

337
00:12:33,720 --> 00:12:37,520
talked about you know the things they

338
00:12:35,700 --> 00:12:40,830
didn't like which is a helpful thing

339
00:12:37,520 --> 00:12:43,020
when you're analyzing okay do I jump in

340
00:12:40,830 --> 00:12:45,180
and go with Haskell or do I you know

341
00:12:43,020 --> 00:12:47,340
lean towards you know the Java or C

342
00:12:45,180 --> 00:12:49,200
sharp or something you know a little

343
00:12:47,340 --> 00:12:50,940
more mainstream yeah I always like it

344
00:12:49,200 --> 00:12:52,110
when I see an article like this and they

345
00:12:50,940 --> 00:12:53,850
include the stuff they didn't like

346
00:12:52,110 --> 00:12:55,500
mm-hmm otherwise it's really easy to

347
00:12:53,850 --> 00:12:57,270
look at it and discount it offhand and

348
00:12:55,500 --> 00:12:58,590
think well they just really like this

349
00:12:57,270 --> 00:13:00,390
and it's their pet language and they

350
00:12:58,590 --> 00:13:01,740
want it to succeed so they're not going

351
00:13:00,390 --> 00:13:05,190
to say anything bad about it is it their

352
00:13:01,740 --> 00:13:08,550
cat language cat or dog people do you

353
00:13:05,190 --> 00:13:16,320
think maybe fish fish people lizard

354
00:13:08,550 --> 00:13:20,180
people I think that's you know it does

355
00:13:16,320 --> 00:13:22,890
add credibility to to this not document

356
00:13:20,180 --> 00:13:23,430
yeah this article very I'm very official

357
00:13:22,890 --> 00:13:25,020
artist

358
00:13:23,430 --> 00:13:29,700
a good term I should use that more often

359
00:13:25,020 --> 00:13:31,200
but they they talk about kind of the

360
00:13:29,700 --> 00:13:36,720
weak tooling aspect this is something

361
00:13:31,200 --> 00:13:38,430
we've come to come to deal with yeah

362
00:13:36,720 --> 00:13:40,350
it's a problem we've definitely run into

363
00:13:38,430 --> 00:13:42,210
right and so you want kind of explain

364
00:13:40,350 --> 00:13:45,510
what we do to kind of counteract this

365
00:13:42,210 --> 00:13:47,250
and sure acknowledge it first just kind

366
00:13:45,510 --> 00:13:49,020
of for a statement of terms I think that

367
00:13:47,250 --> 00:13:51,660
when they talk about tooling they're

368
00:13:49,020 --> 00:13:54,150
talking about like an IDE integration

369
00:13:51,660 --> 00:13:56,610
something like IntelliJ or Visual Studio

370
00:13:54,150 --> 00:13:58,440
where when you're working on code you

371
00:13:56,610 --> 00:13:58,970
can mouse over a certain part and it'll

372
00:13:58,440 --> 00:14:01,380
show you

373
00:13:58,970 --> 00:14:03,390
perhaps the documentation for that thing

374
00:14:01,380 --> 00:14:04,770
or what parameters it expects or where

375
00:14:03,390 --> 00:14:08,480
and your code base that's used you know

376
00:14:04,770 --> 00:14:10,860
mmm stuff that isn't

377
00:14:08,480 --> 00:14:12,720
earth-shattering on its own but a bunch

378
00:14:10,860 --> 00:14:15,480
of small niceties that add up to a

379
00:14:12,720 --> 00:14:17,130
really positive experience and they're

380
00:14:15,480 --> 00:14:19,170
right to say that Haskell is kind of

381
00:14:17,130 --> 00:14:21,720
weak in this regard there are certainly

382
00:14:19,170 --> 00:14:24,990
tools that help the one that we use most

383
00:14:21,720 --> 00:14:27,510
often is GHC ID another one I wish -

384
00:14:24,990 --> 00:14:29,160
another one that I was just thinking

385
00:14:27,510 --> 00:14:30,450
about offhand sided catch off on this

386
00:14:29,160 --> 00:14:33,840
but in Tarot

387
00:14:30,450 --> 00:14:37,860
yeah and Tarot offers like so awesome

388
00:14:33,840 --> 00:14:40,050
IDE experience but it like takes over

389
00:14:37,860 --> 00:14:42,360
people's machines and like crashes them

390
00:14:40,050 --> 00:14:45,180
like yeah and we run into problems with

391
00:14:42,360 --> 00:14:46,770
Haskell IDE engine where the promise of

392
00:14:45,180 --> 00:14:48,450
it is excellent but when you run it for

393
00:14:46,770 --> 00:14:50,940
more than a couple hours it starts

394
00:14:48,450 --> 00:14:53,820
eating up all the RAM it can find mm-hmm

395
00:14:50,940 --> 00:14:56,160
so I think the Haskell is moving in the

396
00:14:53,820 --> 00:14:57,780
right direction and they seem to have

397
00:14:56,160 --> 00:15:00,000
landed on the same solution as us which

398
00:14:57,780 --> 00:15:01,380
is you have your editor up on maybe the

399
00:15:00,000 --> 00:15:02,970
left-hand side of your screen and your

400
00:15:01,380 --> 00:15:03,210
compiler output up on the right-hand

401
00:15:02,970 --> 00:15:05,550
side

402
00:15:03,210 --> 00:15:06,590
and you kind of stitch things together

403
00:15:05,550 --> 00:15:09,090
yourself mm-hmm

404
00:15:06,590 --> 00:15:12,510
obviously not ideal but definitely

405
00:15:09,090 --> 00:15:13,890
workable yeah and just to kind of color

406
00:15:12,510 --> 00:15:16,440
that a bit from my point of view I think

407
00:15:13,890 --> 00:15:18,780
this comes down mostly to lack of

408
00:15:16,440 --> 00:15:21,570
resources because developing all of that

409
00:15:18,780 --> 00:15:22,830
tooling just takes a lot of work and for

410
00:15:21,570 --> 00:15:24,600
these other languages like Java or

411
00:15:22,830 --> 00:15:26,580
JavaScript you have millions of people

412
00:15:24,600 --> 00:15:29,280
working in these languages and that's

413
00:15:26,580 --> 00:15:31,170
not true for Haskell so I'm excited to

414
00:15:29,280 --> 00:15:32,400
see github talk about this because if

415
00:15:31,170 --> 00:15:34,350
they get people interested and excited

416
00:15:32,400 --> 00:15:35,910
about Haskell and working in it then the

417
00:15:34,350 --> 00:15:37,110
tooling is naturally going to improve as

418
00:15:35,910 --> 00:15:38,970
more people get it

419
00:15:37,110 --> 00:15:41,300
with the community no I think that's a

420
00:15:38,970 --> 00:15:43,649
very good point so where to go get hub

421
00:15:41,300 --> 00:15:47,430
awesome well they also kind of talk

422
00:15:43,649 --> 00:15:49,470
about no dependent types why do you

423
00:15:47,430 --> 00:15:50,760
think this is an issue for them so we

424
00:15:49,470 --> 00:15:52,860
already talked a little how they kind of

425
00:15:50,760 --> 00:15:55,050
borrow from current programming language

426
00:15:52,860 --> 00:15:58,140
research and apply it to their problem

427
00:15:55,050 --> 00:16:00,390
domain so they're already in a kind of

428
00:15:58,140 --> 00:16:01,829
unusual situation as far as that goes

429
00:16:00,390 --> 00:16:03,570
and I think that's why they feel this

430
00:16:01,829 --> 00:16:04,529
pain from the lack of dependent typing

431
00:16:03,570 --> 00:16:07,230
because they're pushing

432
00:16:04,529 --> 00:16:11,100
Haskell's type system to its limits and

433
00:16:07,230 --> 00:16:14,190
haskell while it's well revered for

434
00:16:11,100 --> 00:16:15,930
having a strong useful type system it

435
00:16:14,190 --> 00:16:18,089
does not have dependent types and

436
00:16:15,930 --> 00:16:20,190
there's lots of things you can do to try

437
00:16:18,089 --> 00:16:21,630
to pretend like you have them or give

438
00:16:20,190 --> 00:16:23,279
you some of the same benefits of

439
00:16:21,630 --> 00:16:26,010
dependent types but at the end of the

440
00:16:23,279 --> 00:16:28,440
day it doesn't happen and I can't speak

441
00:16:26,010 --> 00:16:29,940
personally to this because I haven't run

442
00:16:28,440 --> 00:16:31,709
into this particular limitation in the

443
00:16:29,940 --> 00:16:33,630
type of development that we do and I

444
00:16:31,709 --> 00:16:34,980
think that most developers would not run

445
00:16:33,630 --> 00:16:37,230
into this problem you know they wouldn't

446
00:16:34,980 --> 00:16:38,459
think oh well I wish I had dependent

447
00:16:37,230 --> 00:16:39,390
types here it doesn't it doesn't come up

448
00:16:38,459 --> 00:16:40,980
that often hmm

449
00:16:39,390 --> 00:16:42,810
but for them it does I don't want to

450
00:16:40,980 --> 00:16:44,640
discount their experience here obviously

451
00:16:42,810 --> 00:16:48,000
they wish they had this and they don't

452
00:16:44,640 --> 00:16:49,470
so the you know the only languages that

453
00:16:48,000 --> 00:16:52,050
do have this they're they're few and far

454
00:16:49,470 --> 00:16:53,449
between stuff like Agda and idris they

455
00:16:52,050 --> 00:16:55,920
have this but they're they're a little

456
00:16:53,449 --> 00:16:59,420
less production-ready than haskell is

457
00:16:55,920 --> 00:17:03,120
they're not used quite as widely right

458
00:16:59,420 --> 00:17:04,589
yeah I don't think we've really thought

459
00:17:03,120 --> 00:17:07,110
of dependent types has never really been

460
00:17:04,589 --> 00:17:08,490
a thing mm-hmm I think that you know

461
00:17:07,110 --> 00:17:10,290
it's a great idea and I'm really

462
00:17:08,490 --> 00:17:11,610
interested in it but day to day there's

463
00:17:10,290 --> 00:17:12,839
not too much where I'm like ah this

464
00:17:11,610 --> 00:17:15,380
would be so much easier if I had

465
00:17:12,839 --> 00:17:17,309
dependent types and yeah

466
00:17:15,380 --> 00:17:21,120
awesome well they also kind of talk

467
00:17:17,309 --> 00:17:23,850
about kind of the lack of info

468
00:17:21,120 --> 00:17:25,980
yeah I like that terminology used in for

469
00:17:23,850 --> 00:17:28,230
a glue it sounds like a something you'd

470
00:17:25,980 --> 00:17:32,160
buy from a TV channel or something right

471
00:17:28,230 --> 00:17:34,290
here here's your info group can talk but

472
00:17:32,160 --> 00:17:36,570
yeah so they've mentioned that for the

473
00:17:34,290 --> 00:17:39,179
actual meat and potatoes of their

474
00:17:36,570 --> 00:17:40,440
program Haskell does a great job but for

475
00:17:39,179 --> 00:17:42,419
the stuff where they have to worry about

476
00:17:40,440 --> 00:17:45,600
like deploying or making containers or

477
00:17:42,419 --> 00:17:48,210
stuff like that it's a little more

478
00:17:45,600 --> 00:17:49,380
difficult and that's mostly because it's

479
00:17:48,210 --> 00:17:50,700
similar to the tooling problem we're

480
00:17:49,380 --> 00:17:53,010
just

481
00:17:50,700 --> 00:17:54,600
not as many people have been using it so

482
00:17:53,010 --> 00:17:57,150
there's not a can solution for like oh I

483
00:17:54,600 --> 00:17:59,220
want to deploy this to AWS or I want to

484
00:17:57,150 --> 00:18:00,720
make a container out of this you can

485
00:17:59,220 --> 00:18:02,070
definitely do those things but you're

486
00:18:00,720 --> 00:18:03,660
probably gonna have to do them yourself

487
00:18:02,070 --> 00:18:05,130
rather than just picking something off

488
00:18:03,660 --> 00:18:07,440
the shelf that says okay yeah I'll

489
00:18:05,130 --> 00:18:09,000
deploy this Python program to Heroku or

490
00:18:07,440 --> 00:18:12,450
whatever it's a little more boilerplate

491
00:18:09,000 --> 00:18:13,860
yeah and and again not a showstopper and

492
00:18:12,450 --> 00:18:17,270
not terribly difficult to get around but

493
00:18:13,860 --> 00:18:20,280
just annoying that it's not there yeah

494
00:18:17,270 --> 00:18:21,810
but then one of the more interesting

495
00:18:20,280 --> 00:18:26,190
ones that I feel like we've encountered

496
00:18:21,810 --> 00:18:29,580
a lot is the kind of the performance

497
00:18:26,190 --> 00:18:32,520
issues with lazy evaluation I think for

498
00:18:29,580 --> 00:18:35,010
us we've had various scripts and you

499
00:18:32,520 --> 00:18:36,540
know things as you know our code is

500
00:18:35,010 --> 00:18:38,490
trying to figure out what it's gonna do

501
00:18:36,540 --> 00:18:39,870
until it actually needs to execute

502
00:18:38,490 --> 00:18:42,420
something it just builds up this giant

503
00:18:39,870 --> 00:18:45,000
funk that you know hangs out all over

504
00:18:42,420 --> 00:18:47,580
the place really everything slows down

505
00:18:45,000 --> 00:18:49,230
you're like what's going on mm-hmm

506
00:18:47,580 --> 00:18:51,080
and then you put one exclamation point

507
00:18:49,230 --> 00:18:54,150
in one place and everything works again

508
00:18:51,080 --> 00:18:57,090
yeah and you know we've thinkin I talked

509
00:18:54,150 --> 00:19:02,880
about the language extension strict data

510
00:18:57,090 --> 00:19:04,710
strict data and so that's how they kind

511
00:19:02,880 --> 00:19:06,240
of I guess kind of acted it but why do

512
00:19:04,710 --> 00:19:08,550
you think for them that's a big issue I

513
00:19:06,240 --> 00:19:10,230
think that lazy evaluation is a

514
00:19:08,550 --> 00:19:13,760
double-edged sword in Haskell for sure

515
00:19:10,230 --> 00:19:15,800
and the main reason for that is that

516
00:19:13,760 --> 00:19:18,090
Haskell is pretty much the only

517
00:19:15,800 --> 00:19:19,710
programming language that I can think of

518
00:19:18,090 --> 00:19:22,140
off the top my head that is lazy by

519
00:19:19,710 --> 00:19:24,890
default every other programming language

520
00:19:22,140 --> 00:19:27,620
is strict by default mm-hmm so as

521
00:19:24,890 --> 00:19:30,330
programmers we're not used to

522
00:19:27,620 --> 00:19:32,220
identifying and solving problems that

523
00:19:30,330 --> 00:19:34,140
stem from laziness because we rarely

524
00:19:32,220 --> 00:19:35,790
encounter them in other languages you

525
00:19:34,140 --> 00:19:37,770
have to explicitly opt in so like in

526
00:19:35,790 --> 00:19:39,980
Python you can make a generator or in

527
00:19:37,770 --> 00:19:42,060
JavaScript you do all the async stuff to

528
00:19:39,980 --> 00:19:45,050
pretend like you have laziness

529
00:19:42,060 --> 00:19:47,280
whereas in Haskell it's everywhere so

530
00:19:45,050 --> 00:19:48,390
people just aren't used to looking for

531
00:19:47,280 --> 00:19:51,030
those types of problems and so they're

532
00:19:48,390 --> 00:19:54,480
bound to crop up every now and then that

533
00:19:51,030 --> 00:19:57,210
being said they're usually not terribly

534
00:19:54,480 --> 00:20:00,060
hard to diagnose and fix once you have a

535
00:19:57,210 --> 00:20:01,410
couple tricks in your bag but the first

536
00:20:00,060 --> 00:20:02,880
time that you run into them they can be

537
00:20:01,410 --> 00:20:04,230
completely mystifying because you can

538
00:20:02,880 --> 00:20:06,450
look at code and it looks totally

539
00:20:04,230 --> 00:20:08,690
reasonable but for whatever reason the

540
00:20:06,450 --> 00:20:11,850
way that you wrote it either you know

541
00:20:08,690 --> 00:20:13,110
generates too much too many thunks like

542
00:20:11,850 --> 00:20:14,520
you mentioned and you don't evaluate

543
00:20:13,110 --> 00:20:16,830
them at the right time or just something

544
00:20:14,520 --> 00:20:18,240
like that and it can be really difficult

545
00:20:16,830 --> 00:20:19,830
to figure out what's going on and again

546
00:20:18,240 --> 00:20:23,130
this comes back to the lack of tooling

547
00:20:19,830 --> 00:20:25,470
if there was better tooling to analyze

548
00:20:23,130 --> 00:20:28,110
the laziness of your program this would

549
00:20:25,470 --> 00:20:31,169
be an easier problem to solve so maybe

550
00:20:28,110 --> 00:20:33,530
booth time maybe with time all right the

551
00:20:31,169 --> 00:20:37,110
last one this one hits home for us is

552
00:20:33,530 --> 00:20:38,850
they kind of said you know it's got a

553
00:20:37,110 --> 00:20:42,330
notorious reputation of being too hard

554
00:20:38,850 --> 00:20:44,309
to learn as you know a bunch of junior

555
00:20:42,330 --> 00:20:47,010
developers for the most part - you and

556
00:20:44,309 --> 00:20:51,990
Cody Learning High School in within the

557
00:20:47,010 --> 00:20:53,640
last two years you know it's had it's

558
00:20:51,990 --> 00:20:55,320
like a little bit of growing pain in the

559
00:20:53,640 --> 00:20:56,700
beginning but once you understand like

560
00:20:55,320 --> 00:20:58,440
the concept and the paradigm of

561
00:20:56,700 --> 00:21:02,010
functional programming it becomes a lot

562
00:20:58,440 --> 00:21:04,230
more attainable yeah to really conquer

563
00:21:02,010 --> 00:21:06,120
the language and you know have a good

564
00:21:04,230 --> 00:21:08,370
understanding of it without you maybe

565
00:21:06,120 --> 00:21:09,720
not the deepest understanding but gonna

566
00:21:08,370 --> 00:21:12,360
have a general idea of what's going on

567
00:21:09,720 --> 00:21:15,030
so that what do they have to say about

568
00:21:12,360 --> 00:21:18,179
that I think they say something very

569
00:21:15,030 --> 00:21:19,679
similar to what we think and I hope have

570
00:21:18,179 --> 00:21:20,660
said but if we haven't yet we'll say now

571
00:21:19,679 --> 00:21:23,340
that

572
00:21:20,660 --> 00:21:25,559
Haskell's does have this reputation of

573
00:21:23,340 --> 00:21:27,540
being difficult to learn but it's not

574
00:21:25,559 --> 00:21:29,190
that difficult and it's especially not

575
00:21:27,540 --> 00:21:30,450
that difficult to get to a working

576
00:21:29,190 --> 00:21:32,070
knowledge where maybe you don't have a

577
00:21:30,450 --> 00:21:34,980
super deep understanding of everything

578
00:21:32,070 --> 00:21:37,470
that's going on but you can get work

579
00:21:34,980 --> 00:21:39,510
done and you can feel effective and be

580
00:21:37,470 --> 00:21:41,100
effective without knowing you don't you

581
00:21:39,510 --> 00:21:43,590
don't have to learn category theory or

582
00:21:41,100 --> 00:21:45,090
really like understand what is a man add

583
00:21:43,590 --> 00:21:49,980
in order to program in haskell day to

584
00:21:45,090 --> 00:21:52,320
day and they say especially with some

585
00:21:49,980 --> 00:21:53,880
type of you know mentor or tutor on the

586
00:21:52,320 --> 00:21:56,160
team you can get people up to speed

587
00:21:53,880 --> 00:21:57,900
really quickly and we've seen that we

588
00:21:56,160 --> 00:21:59,429
hired somebody a month ago and they got

589
00:21:57,900 --> 00:22:02,490
up to speed basically within the first

590
00:21:59,429 --> 00:22:04,980
week now granted they obviously don't

591
00:22:02,490 --> 00:22:06,270
understand all of haskell everything i

592
00:22:04,980 --> 00:22:09,150
mean it's a huge language there's a lot

593
00:22:06,270 --> 00:22:11,130
to know right but they know enough to be

594
00:22:09,150 --> 00:22:13,740
effective and write code that works and

595
00:22:11,130 --> 00:22:16,020
submit it for PR and get it you know

596
00:22:13,740 --> 00:22:18,570
into production within a week or two of

597
00:22:16,020 --> 00:22:22,219
being hired right it's not

598
00:22:18,570 --> 00:22:25,139
insurmountable yeah then I think another

599
00:22:22,219 --> 00:22:27,329
attribute for us attribute to like the

600
00:22:25,139 --> 00:22:28,769
ability to learn high school has been

601
00:22:27,329 --> 00:22:30,929
like the idea of promiscuous pairing

602
00:22:28,769 --> 00:22:32,999
which for those of those of you

603
00:22:30,929 --> 00:22:34,859
listeners yes check it out there's a

604
00:22:32,999 --> 00:22:36,359
cool paper on it so we've been doing it

605
00:22:34,859 --> 00:22:38,279
for a little while now and we find it

606
00:22:36,359 --> 00:22:40,799
very effective and it allows us

607
00:22:38,279 --> 00:22:43,969
knowledge transfer it really well so you

608
00:22:40,799 --> 00:22:46,589
know I did a shameless plug for Jason

609
00:22:43,969 --> 00:22:48,599
yeah he's all about it and it really

610
00:22:46,589 --> 00:22:51,089
ties in to what get this semantics team

611
00:22:48,599 --> 00:22:52,829
at github said of you know having a

612
00:22:51,089 --> 00:22:55,259
tutor somebody who knows the ropes to

613
00:22:52,829 --> 00:22:58,699
show the new person promiscuous pairing

614
00:22:55,259 --> 00:23:01,589
just forces that every time around

615
00:22:58,699 --> 00:23:02,959
teaching I'm whispering and whispering

616
00:23:01,589 --> 00:23:06,839
into a microphone that's kind of rude

617
00:23:02,959 --> 00:23:09,419
alright and obviously this program is

618
00:23:06,839 --> 00:23:11,429
pretty large semantic like as far as

619
00:23:09,419 --> 00:23:13,829
like yeah the depth of what it can do

620
00:23:11,429 --> 00:23:16,319
but it's only 20,000 lines of code

621
00:23:13,829 --> 00:23:18,179
mmm-hmm yeah and that's amazing because

622
00:23:16,319 --> 00:23:19,919
as they point out several times in their

623
00:23:18,179 --> 00:23:22,319
article if they had written this in

624
00:23:19,919 --> 00:23:25,019
let's say Java they may have written

625
00:23:22,319 --> 00:23:26,969
20,000 lines of just boilerplate whereas

626
00:23:25,019 --> 00:23:29,639
the entire Haskell program would fit

627
00:23:26,969 --> 00:23:31,589
into that same space so yeah it's

628
00:23:29,639 --> 00:23:34,229
phenomenal they can get so much done

629
00:23:31,589 --> 00:23:37,169
with so little code yeah I think it's

630
00:23:34,229 --> 00:23:39,089
just incredible so I I do think this is

631
00:23:37,169 --> 00:23:40,499
a really great article and I would

632
00:23:39,089 --> 00:23:43,229
definitely encourage all of our

633
00:23:40,499 --> 00:23:44,549
listeners to check it out for sure but

634
00:23:43,229 --> 00:23:46,409
you have anything else you'd like to add

635
00:23:44,549 --> 00:23:48,569
on it I don't think so

636
00:23:46,409 --> 00:23:49,949
just want to reiterate that it's great

637
00:23:48,569 --> 00:23:51,559
to see another big company like github

638
00:23:49,949 --> 00:23:54,029
using haskell in production and

639
00:23:51,559 --> 00:23:55,259
generally coming away with a positive

640
00:23:54,029 --> 00:23:57,059
experience obviously they had some

641
00:23:55,259 --> 00:23:59,549
things that they didn't like too much

642
00:23:57,059 --> 00:24:01,319
but overall they were really positive

643
00:23:59,549 --> 00:24:03,239
about it and it seems like if they had

644
00:24:01,319 --> 00:24:05,639
to choose it again they would yeah we'll

645
00:24:03,239 --> 00:24:08,429
see the octocat soon with some sweet

646
00:24:05,639 --> 00:24:11,909
high school tattoos yeah the purely

647
00:24:08,429 --> 00:24:13,319
functional octocat yeah well awesome

648
00:24:11,909 --> 00:24:16,079
we'll tailor it's been really really fun

649
00:24:13,319 --> 00:24:17,609
talking it's been great talking with you

650
00:24:16,079 --> 00:24:20,099
cam thanks for being on the show with me

651
00:24:17,609 --> 00:24:21,719
of course always anytime and thank you

652
00:24:20,099 --> 00:24:24,719
for listening to the haskell weekly

653
00:24:21,719 --> 00:24:26,909
podcast this has been episode number 13

654
00:24:24,719 --> 00:24:28,859
if you liked what you heard find out

655
00:24:26,909 --> 00:24:31,739
more at our website haskell weekly dot

656
00:24:28,859 --> 00:24:32,620
news also please take a minute to rate

657
00:24:31,739 --> 00:24:34,480
and review us

658
00:24:32,620 --> 00:24:35,559
I Tunes it helps us out a lot I think

659
00:24:34,480 --> 00:24:37,620
right now Cameron and I are the only

660
00:24:35,559 --> 00:24:42,040
people that have reviewed us Cecil yeah

661
00:24:37,620 --> 00:24:43,420
reviewed this episode like all of the

662
00:24:42,040 --> 00:24:45,160
other ones we've done so far was

663
00:24:43,420 --> 00:24:47,260
actually recorded in our own office the

664
00:24:45,160 --> 00:24:49,660
IT Pro TV studios so I just want to give

665
00:24:47,260 --> 00:24:51,640
a shout out to IT Pro for recording this

666
00:24:49,660 --> 00:24:54,430
whole thing woohoo

667
00:24:51,640 --> 00:24:56,080
and I - Pro what we do is provide IT

668
00:24:54,430 --> 00:24:58,000
training that's both effective and

669
00:24:56,080 --> 00:25:00,130
entertaining so that sounds interesting

670
00:24:58,000 --> 00:25:03,580
to you please go find out more at IT Pro

671
00:25:00,130 --> 00:25:07,200
TV thanks again for listening and we'll

672
00:25:03,580 --> 00:25:07,200
see you next week bye adios
